<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NSW Property Sales Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .controls {
            margin-bottom: 30px;
            text-align: center;
        }
        select {
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            min-width: 250px;
        }
        .loading {
            text-align: center;
            color: #666;
            margin: 20px 0;
            display: none;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .stat-card {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .stat-card.property-types-card {
            grid-column: span 2;
            text-align: left;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: center;
            min-height: 60px;
        }
        .stat-value.property-types {
            font-size: 12px;
            line-height: 1.2;
            color: #495057;
            margin: 0 10px;
            text-align: center;
        }
        .stat-label {
            color: #666;
            margin-top: 5px;
        }
        .chart-container {
            position: relative;
            height: 500px;
            margin-top: 20px;
        }
        .error {
            color: #dc3545;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 4px;
            margin: 20px 0;
            display: none;
        }
        .attribution {
            margin-top: 40px;
            padding: 20px;
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
            border-radius: 4px;
        }
        .attribution h3 {
            margin-top: 0;
            color: #333;
            font-size: 18px;
        }
        .attribution p {
            margin: 8px 0;
            color: #555;
            line-height: 1.4;
        }
        .attribution a {
            color: #007bff;
            text-decoration: none;
        }
        .attribution a:hover {
            text-decoration: underline;
        }
        .attribution em {
            font-style: italic;
            color: #666;
            font-size: 14px;
        }
        .source-code {
            margin-top: 20px;
            text-align: center;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        .source-code p {
            margin: 0;
            color: #555;
        }
        .source-code a {
            color: #007bff;
            text-decoration: none;
            font-weight: normal;
        }
        .source-code a:hover {
            text-decoration: underline;
        }
        input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        input:disabled + label {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .tooltip {
            position: absolute;
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 250px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            line-height: 1.3;
        }
        .tooltip.show {
            opacity: 1;
        }
        .trend-type-label {
            position: relative;
            cursor: help;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>NSW Property Sales Analyzer</h1>
        
        <div class="controls">
            <label for="localitySelect">Select a Locality:</label>
            <select id="localitySelect">
                <option value="">Loading localities...</option>
            </select>
            
            <div style="margin-top: 15px;">
                <label>
                    <input type="checkbox" id="showIndividualSales">
                    Show Individual Purchases
                </label>
            </div>
            
            <div style="margin-top: 15px;">
                <label>Pricing Display:</label><br>
                <label><input type="radio" name="pricingType" value="total" checked> Total Price</label>
                <label style="margin-left: 15px;"><input type="radio" name="pricingType" value="per_sqm"> Price per m² (when area available)</label>
            </div>
            
            <div style="margin-top: 15px;">
                <label>Trend Period:</label><br>
                <label><input type="radio" name="trendPeriod" value="monthly"> Monthly</label>
                <label style="margin-left: 15px;"><input type="radio" name="trendPeriod" value="quarterly"> Quarterly</label>
                <label style="margin-left: 15px;"><input type="radio" name="trendPeriod" value="yearly" checked> Yearly</label>
            </div>
            
            <div style="margin-top: 15px;">
                <label>Long-term Trend Type:</label><br>
                <label class="trend-type-label" data-tooltip="Straight line through data points using mathematical regression. Good for identifying consistent long-term growth or decline patterns."><input type="radio" name="trendType" value="linear" checked> Linear Regression</label>
                <label class="trend-type-label" style="margin-left: 15px;" data-tooltip="Simple compound annual growth rate line from earliest to latest data point. Shows the constant growth rate needed to reach current levels."><input type="radio" name="trendType" value="cagr"> CAGR Line</label>
                <label class="trend-type-label" style="margin-left: 15px;" data-tooltip="Curved trend line using moving averages to create smooth patterns. Shows gentle market cycles and turning points."><input type="radio" name="trendType" value="polynomial"> Polynomial (Curved)</label>
                <label class="trend-type-label" style="margin-left: 15px;" data-tooltip="Rolling average that smooths out short-term noise. Follows market movements closely while reducing volatility spikes."><input type="radio" name="trendType" value="moving"> Moving Average</label>
                <label class="trend-type-label" style="margin-left: 15px;" data-tooltip="Exponential smoothing that adapts to recent trends. Reacts quickly to market changes while maintaining smooth progression."><input type="radio" name="trendType" value="smoothed"> Smoothed</label>
            </div>
            
            <div style="margin-top: 15px;">
                <label>Long-term Trend Based On:</label><br>
                <label><input type="radio" name="trendTimeFrame" value="all"> All Data</label>
                <label style="margin-left: 15px;"><input type="radio" name="trendTimeFrame" value="5"> Last 5 Years</label>
                <label style="margin-left: 15px;"><input type="radio" name="trendTimeFrame" value="10"> Last 10 Years</label>
                <label style="margin-left: 15px;"><input type="radio" name="trendTimeFrame" value="15" checked> Last 15 Years</label>
            </div>
        </div>
        
        <div class="loading" id="loading">Loading property data...</div>
        <div class="error" id="error"></div>
        
        <div class="stats" id="stats" style="display: none;">
            <div class="stat-card">
                <div class="stat-value" id="totalSales">0</div>
                <div class="stat-label">Total Sales</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgPrice">$0</div>
                <div class="stat-label">Latest 100 Avg Price</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="medianPrice">$0</div>
                <div class="stat-label">Latest 100 Median Price</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="priceRange">$0</div>
                <div class="stat-label">Price Range</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="outliersRemoved">0</div>
                <div class="stat-label">Outliers Removed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="trendGrowth">-</div>
                <div class="stat-label">Trend Growth (% p.a.)</div>
            </div>
            <div class="stat-card property-types-card">
                <div class="stat-label" style="width: 100%; margin-bottom: 10px; text-align: center;">Property Types</div>
                <div id="propertyTypes" style="display: flex; flex-wrap: wrap; justify-content: space-around; width: 100%;">-</div>
            </div>
        </div>
        
        <div class="chart-container">
            <canvas id="priceChart"></canvas>
        </div>
        
        <div class="chart-container" style="margin-top: 20px; height: 300px;">
            <canvas id="volumeChart"></canvas>
        </div>
        
        <div class="chart-container" style="margin-top: 20px; height: 600px;">
            <canvas id="streetChart"></canvas>
        </div>
        
        <div class="chart-container" style="margin-top: 20px; height: 600px;">
            <canvas id="streetCountChart"></canvas>
        </div>
        
        <div class="attribution">
            <h3>Data Source</h3>
            <p>This analysis uses NSW Valuer General's Bulk Property Sales Information, acquired on 16th January 2026.</p>
            <p>The data is licensed under a Creative Commons license and can be downloaded from:</p>
            <p><a href="https://valuation.property.nsw.gov.au/embed/propertySalesInformation" target="_blank">NSW Valuer General - Property Sales Information</a></p>
        </div>
        
        <div class="source-code">
            <p><strong>Source Code:</strong> <a href="https://github.com/reductor/nswproperty" target="_blank">GitHub Repository</a></p>
        </div>
    </div>

    <script>
        let chart = null;
        let volumeChart = null;
        let streetChart = null;
        let streetCountChart = null;
        let localities = [];

        // Load localities on page load
        window.addEventListener('load', loadLocalities);

        async function loadLocalities() {
            try {
                const response = await fetch('localities.json');
                localities = await response.json();
                
                const select = document.getElementById('localitySelect');
                select.innerHTML = '<option value="">Select a locality...</option>';
                
                localities.forEach(locality => {
                    const option = document.createElement('option');
                    option.value = locality;
                    option.textContent = locality.replace(/_/g, ' ');
                    select.appendChild(option);
                });
                
                select.addEventListener('change', handleLocalityChange);
                
                // Check URL for locality parameter and restore selection
                const urlParams = new URLSearchParams(window.location.search);
                const localityFromUrl = urlParams.get('locality');
                if (localityFromUrl && localities.includes(localityFromUrl)) {
                    select.value = localityFromUrl;
                    // Trigger the change event to load the data
                    const event = new Event('change');
                    select.dispatchEvent(event);
                }
                
            } catch (error) {
                showError('Failed to load localities: ' + error.message);
            }
        }

        async function handleLocalityChange(event) {
            const selectedLocality = event.target.value;
            
            // Update URL with selected locality
            updateURL(selectedLocality);
            
            if (!selectedLocality) {
                hideChart();
                return;
            }
            
            showLoading(true);
            hideError();
            
            try {
                const datFile = `localities/${selectedLocality}.DAT`;
                const response = await fetch(datFile);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${datFile}`);
                }
                
                const content = await response.text();
                const result = parsePropertyData(content);
                
                if (result.data.length === 0) {
                    throw new Error('No property data found in the selected locality');
                }
                
                displayChart(result.data, selectedLocality);
                displayVolumeChart(result.data, selectedLocality);
                displayStreetChart(result.data, selectedLocality);
                updateStats(result.data, result.outliersRemoved);
                
                // Setup event listeners
                const checkbox = document.getElementById('showIndividualSales');
                const trendPeriodRadios = document.querySelectorAll('input[name="trendPeriod"]');
                const trendTimeFrameRadios = document.querySelectorAll('input[name="trendTimeFrame"]');
                const trendTypeRadios = document.querySelectorAll('input[name="trendType"]');
                const pricingTypeRadios = document.querySelectorAll('input[name="pricingType"]');
                
                checkbox.onchange = () => {
                    displayChart(result.data, selectedLocality);
                };
                
                pricingTypeRadios.forEach(radio => {
                    radio.onchange = () => {
                        invalidatePricingCache();
                        displayChart(result.data, selectedLocality);
                        displayStreetChart(result.data, selectedLocality);
                        updateStats(result.data, result.outliersRemoved);
                    };
                });
                
                trendPeriodRadios.forEach(radio => {
                    radio.onchange = () => {
                        displayChart(result.data, selectedLocality);
                    };
                });
                
                trendTimeFrameRadios.forEach(radio => {
                    radio.onchange = () => {
                        displayChart(result.data, selectedLocality);
                    };
                });
                
                trendTypeRadios.forEach(radio => {
                    radio.onchange = () => {
                        updateTimeFrameControls();
                        displayChart(result.data, selectedLocality);
                    };
                });
                
                // Set initial state of time frame controls
                updateTimeFrameControls();
                
                // Setup tooltips for trend type labels
                setupTooltips();
                
                function updateTimeFrameControls() {
                    const selectedTrendType = document.querySelector('input[name="trendType"]:checked').value;
                    const isRegressionBased = selectedTrendType === 'linear' || selectedTrendType === 'polynomial' || selectedTrendType === 'cagr';
                    const timeFrameRadios = document.querySelectorAll('input[name="trendTimeFrame"]');
                    
                    timeFrameRadios.forEach(tfRadio => {
                        tfRadio.disabled = !isRegressionBased;
                        // Find the label for this radio button and update its style
                        const label = tfRadio.parentElement;
                        if (label && label.tagName === 'LABEL') {
                            label.style.opacity = isRegressionBased ? '1' : '0.5';
                            label.style.cursor = isRegressionBased ? 'pointer' : 'not-allowed';
                        }
                    });
                }
                
                function setupTooltips() {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';
                    document.body.appendChild(tooltip);
                    
                    const trendLabels = document.querySelectorAll('.trend-type-label');
                    
                    trendLabels.forEach(label => {
                        label.addEventListener('mouseenter', (e) => {
                            const tooltipText = e.target.getAttribute('data-tooltip');
                            if (tooltipText) {
                                tooltip.textContent = tooltipText;
                                tooltip.classList.add('show');
                                
                                // Position tooltip near the element, accounting for scroll
                                const rect = e.target.getBoundingClientRect();
                                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                                const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                                
                                tooltip.style.left = (rect.left + scrollLeft + rect.width / 2 - tooltip.offsetWidth / 2) + 'px';
                                tooltip.style.top = (rect.bottom + scrollTop + 10) + 'px';
                            }
                        });
                        
                        label.addEventListener('mouseleave', (e) => {
                            // Add a small delay to prevent flickering
                            setTimeout(() => {
                                // Check if mouse is not over the tooltip
                                if (!tooltip.matches(':hover') && !e.target.matches(':hover')) {
                                    tooltip.classList.remove('show');
                                }
                            }, 100);
                        });
                        
                        label.addEventListener('mousemove', (e) => {
                            // Only update position if tooltip is visible
                            if (tooltip.classList.contains('show')) {
                                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                                const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                                
                                tooltip.style.left = (e.clientX + scrollLeft - tooltip.offsetWidth / 2) + 'px';
                                tooltip.style.top = (e.clientY + scrollTop + 15) + 'px';
                            }
                        });
                    });
                    
                    // Also hide tooltip when mouse leaves the tooltip itself
                    tooltip.addEventListener('mouseleave', () => {
                        tooltip.classList.remove('show');
                    });
                }
                
            } catch (error) {
                showError('Failed to load property data: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        function updateURL(locality) {
            const url = new URL(window.location);
            if (locality) {
                url.searchParams.set('locality', locality);
            } else {
                url.searchParams.delete('locality');
            }
            // Update URL without reloading the page
            window.history.replaceState({}, '', url);
        }

        function parsePropertyData(content) {
    /*
    NSW Property Sales .DAT File Field Structure (Current Format):
    B-Record Fields (semicolon-separated):
    0:  Record Type (B)
    1:  District Code
    2:  Property ID
    3:  Sale Counter
    4:  Download Date/Time
    5:  Property Name
    6:  Unit Number
    7:  House Number
    8:  Street Name
    9:  Property Locality (Suburb) - USED FOR GROUPING
    10: Post Code
    11: Area
    12: Area Type
    13: Contract Date
    14: Settlement Date (CCYYMMDD) - USED FOR CHART X-AXIS
    15: Purchase Price - USED FOR CHART Y-AXIS
    16: Zoning
    17: Nature of Property
    18: Primary Purpose (RESIDENCE/COMMERCIAL/etc) - USED FOR PROPERTY TYPE FILTERING
    19: Strata Lot Number
    20: Component Code
    21: Sale Code
    22: % Interest of Sale
    23: Dealing Number
    
    Note: Archive files are pre-converted to this format by group_by_locality.py
    */
            const lines = content.split('\n');
            const properties = [];
            const areaTypeStats = {}; // Track area types found
            
            for (const line of lines) {
                if (line.trim().startsWith('B;')) {
                    const fields = line.split(';');
                    
                    if (fields.length >= 19) {
                        const dateStr = fields[14].trim(); // Field 15 (0-indexed as 14)
                        const priceStr = fields[15].trim(); // Field 16 (0-indexed as 15)
                        const propertyType = fields[18].trim(); // Field 19 (0-indexed as 18)
                        const areaStr = fields[11].trim(); // Field 12 (0-indexed as 11)
                        const areaType = fields[12].trim(); // Field 13 (0-indexed as 12)
                        const streetName = fields[8].trim(); // Field 9 (0-indexed as 8)
                        
                        if (dateStr && priceStr && priceStr !== '0' && !isNaN(priceStr)) {
                            const date = parseDate(dateStr);
                            const price = parseInt(priceStr);
                            
                            // Only include data from 1990 onwards and reasonable price range
                            if (date && price > 10000 && price < 100000000 && date.getFullYear() >= 1990) {
                                const property = { 
                                    date, 
                                    price, 
                                    propertyType,
                                    streetName,
                                    area: null,
                                    areaType: null,
                                    _pricePerSqm: null,
                                    _hasAreaData: null
                                };
                                
                                // Only parse area data if we have it
                                if (areaStr && areaType) {
                                    property.area = !isNaN(areaStr) ? parseFloat(areaStr) : null;
                                    property.areaType = areaType;
                                    // More inclusive: allow any area type if area > 0
                                    // Common types: 'M' (square meters), 'H' (hectares), 'A' (acres), etc.
                                    property._hasAreaData = property.area && property.area > 0;
                                    
                                    // Track area types for debugging
                                    if (property._hasAreaData) {
                                        areaTypeStats[areaType] = (areaTypeStats[areaType] || 0) + 1;
                                    }
                                }
                                
                                // Add lazy getter for pricePerSqm
                                Object.defineProperty(property, 'pricePerSqm', {
                                    get() {
                                        if (this._pricePerSqm === null && this._hasAreaData) {
                                            let areaInSqm = this.area;
                                            
                                            // Convert different area types to square meters
                                            switch(this.areaType) {
                                                case 'M': // Already in square meters
                                                    break;
                                                case 'H': // Hectares
                                                    areaInSqm = this.area * 10000;
                                                    break;
                                                case 'A': // Acres  
                                                    areaInSqm = this.area * 4046.86;
                                                    break;
                                                default:
                                                    // For unknown area types, assume square meters
                                                    console.log(`Unknown area type: ${this.areaType}, assuming square meters`);
                                                    break;
                                            }
                                            
                                            this._pricePerSqm = this.price / areaInSqm;
                                        }
                                        return this._pricePerSqm;
                                    }
                                });
                                
                                properties.push(property);
                            }
                        }
                    }
                }
            }
            
            // Filter outliers using IQR method
            const originalCount = properties.length;
            const filteredProperties = filterOutliers(properties);
            const outliersRemoved = originalCount - filteredProperties.length;
            
            // Sort by date
            const sortedData = filteredProperties.sort((a, b) => a.date - b.date);
            
            // Log area type statistics for debugging
            const propertiesWithArea = properties.filter(p => p._hasAreaData).length;
            console.log(`Area data statistics for this locality:`);
            console.log(`Properties with area data: ${propertiesWithArea} of ${properties.length} (${(propertiesWithArea/properties.length*100).toFixed(1)}%)`);
            console.log('Area types found:', areaTypeStats);
            
            return {
                data: sortedData,
                outliersRemoved: outliersRemoved
            };
        }

        function filterOutliers(data) {
            if (data.length < 4) return data; // Need at least 4 data points for IQR
            
            const prices = data.map(item => item.price).sort((a, b) => a - b);
            const q1Index = Math.floor(prices.length * 0.25);
            const q3Index = Math.floor(prices.length * 0.75);
            const q1 = prices[q1Index];
            const q3 = prices[q3Index];
            const iqr = q3 - q1;
            
            // More aggressive filtering for low outliers, standard for high outliers
            const lowerBound = Math.max(10000, q1 - 0.5 * iqr); // Minimum $10,000 and less aggressive IQR
            const upperBound = q3 + 1.5 * iqr;
            
            // Filter out outliers
            const filtered = data.filter(item => 
                item.price >= lowerBound && item.price <= upperBound
            );
            
            console.log(`Original data points: ${data.length}, After outlier removal: ${filtered.length}`);
            console.log(`Price range: $${lowerBound.toLocaleString()} - $${upperBound.toLocaleString()}`);
            
            return filtered;
        }

        function parseDate(dateStr) {
            if (dateStr.length !== 8) return null;
            
            const year = parseInt(dateStr.substring(0, 4));
            const month = parseInt(dateStr.substring(4, 6)) - 1; // Month is 0-indexed
            const day = parseInt(dateStr.substring(6, 8));
            
            const date = new Date(year, month, day);
            return isNaN(date.getTime()) ? null : date;
        }

        function displayChart(data, locality) {
            // Store data globally for growth rate calculations
            window.currentLocalityData = data;
            
            const ctx = document.getElementById('priceChart').getContext('2d');
            
            if (chart) {
                chart.destroy();
            }
            
            const showIndividual = document.getElementById('showIndividualSales').checked;
            const pricingType = getCachedPricingMode();
            
            // Filter data for price per sqm if selected (do this once)
            let chartData = data;
            if (pricingType === 'per_sqm') {
                chartData = data.filter(item => item._hasAreaData);
                if (chartData.length === 0) {
                    // Show message if no area data available
                    const errorDiv = document.getElementById('error');
                    errorDiv.textContent = 'No properties with area data (area type "M") available for this locality.';
                    errorDiv.style.display = 'block';
                    return;
                } else {
                    // Clear any previous error
                    document.getElementById('error').style.display = 'none';
                }
            }
            
            // Group data by property type
            const dataByPropertyType = groupDataByPropertyType(chartData);
            const propertyTypes = Object.keys(dataByPropertyType);
            
            const datasets = [];
            
            // Define colors for different property types
            const colors = [
                { bg: 'rgba(255, 99, 132, 0.6)', border: 'rgba(255, 99, 132, 1)' },
                { bg: 'rgba(54, 162, 235, 0.6)', border: 'rgba(54, 162, 235, 1)' },
                { bg: 'rgba(75, 192, 192, 0.6)', border: 'rgba(75, 192, 192, 1)' },
                { bg: 'rgba(255, 206, 86, 0.6)', border: 'rgba(255, 206, 86, 1)' },
                { bg: 'rgba(153, 102, 255, 0.6)', border: 'rgba(153, 102, 255, 1)' },
                { bg: 'rgba(255, 159, 64, 0.6)', border: 'rgba(255, 159, 64, 1)' },
                { bg: 'rgba(199, 199, 199, 0.6)', border: 'rgba(199, 199, 199, 1)' },
                { bg: 'rgba(83, 102, 255, 0.6)', border: 'rgba(83, 102, 255, 1)' }
            ];
            
            // Add individual sales datasets if checkbox is checked
            if (showIndividual) {
                propertyTypes.forEach((propertyType, index) => {
                    const typeData = dataByPropertyType[propertyType];
                    const color = colors[index % colors.length];
                    
                    datasets.push({
                        label: `${propertyType || 'Unknown'} Sales`,
                        data: typeData.map(item => ({ x: item.date, y: item.price })),
                        backgroundColor: color.bg,
                        borderColor: color.border,
                        borderWidth: 1,
                        pointRadius: 3,
                        hidden: propertyType === 'VACANT LAND' || propertyType === 'COMMERCIAL'
                    });
                });
            }
            
            // Add trend lines for each property type
            propertyTypes.forEach((propertyType, index) => {
                const typeData = dataByPropertyType[propertyType];
                if (typeData.length >= 3) { // Only create trend line if we have enough data
                    // Get selected trend period and type
                    const selectedPeriod = document.querySelector('input[name="trendPeriod"]:checked').value;
                    const selectedTimeFrame = document.querySelector('input[name="trendTimeFrame"]:checked').value;
                    const selectedTrendType = document.querySelector('input[name="trendType"]:checked').value;
                    
                    let trendData;
                    switch(selectedPeriod) {
                        case 'quarterly':
                            trendData = groupByQuarter(typeData);
                            break;
                        case 'yearly':
                            trendData = groupByYear(typeData);
                            break;
                        case 'monthly':
                        default:
                            trendData = groupByMonth(typeData);
                            break;
                    }
                    
                    // Calculate trend based on selected type
                    let linearTrendData;
                    switch(selectedTrendType) {
                        case 'polynomial':
                            linearTrendData = calculatePolynomialTrend(typeData, selectedTimeFrame);
                            break;
                        case 'cagr':
                            linearTrendData = calculateCAGRTrend(typeData, selectedTimeFrame);
                            break;
                        case 'moving':
                            linearTrendData = calculateMovingAverageTrend(typeData, null); // Always use all data
                            break;
                        case 'smoothed':
                            linearTrendData = calculateSmoothedTrend(typeData, null); // Always use all data
                            break;
                        case 'linear':
                        default:
                            linearTrendData = calculateLinearTrend(typeData, selectedTimeFrame);
                            break;
                    }
                    
                    const color = colors[index % colors.length];
                    
                    // Create interpolated trend data that matches the selected period data points
                    let interpolatedTrend;
                    if (selectedTrendType === 'moving' || selectedTrendType === 'smoothed') {
                        // For moving average and smoothed, use the trend data directly
                        interpolatedTrend = linearTrendData;
                    } else {
                        // For linear and polynomial, interpolate to match period data points
                        interpolatedTrend = interpolateTrendForPeriod(trendData, linearTrendData);
                    }
                    
                    const isHidden = propertyType === 'VACANT LAND' || propertyType === 'COMMERCIAL';
                    
                    // Overall trend line (render first as base)
                    datasets.push({
                        label: `${propertyType || 'Unknown'}`,
                        data: interpolatedTrend,
                        type: 'line',
                        backgroundColor: 'rgba(0, 0, 0, 0.1)',
                        borderColor: color.border,
                        borderWidth: 2,
                        fill: (selectedTrendType === 'moving' || selectedTrendType === 'smoothed') ? false : { above: "rgba(255, 0, 0, 0.2)", below: "rgba(0, 0, 255, 0.2)", target: "+1"},
                        tension: (selectedTrendType === 'moving' || selectedTrendType === 'smoothed') ? 0.4 : 0.1,
                        pointRadius: 0,
                        borderDash: [10, 5],
                        hidden: isHidden,
                        legendGroup: propertyType,
                        trendType: 'overall'
                    });
                
                    // Period trend line (on top)
                    datasets.push({
                        label: `${propertyType || 'Unknown'}`,
                        data: trendData,
                        type: 'line',
                        backgroundColor: color.bg,
                        borderColor: color.border,
                        borderWidth: 3,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 4,
                        hidden: isHidden,
                        legendGroup: propertyType,
                        trendType: selectedPeriod
                    });
                }
            });
            
            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Property ${pricingType === 'per_sqm' ? 'Price per m²' : 'Prices'} in ${locality.replace(/_/g, ' ')}`
                        },
                        legend: {
                            display: true,
                            onClick: function(e, legendItem, legend) {
                                const chart = legend.chart;
                                const datasetIndex = legendItem.datasetIndex;
                                const dataset = chart.data.datasets[datasetIndex];
                                
                                // Toggle visibility for all datasets with the same legendGroup
                                if (dataset.legendGroup) {
                                    chart.data.datasets.forEach((ds, index) => {
                                        if (ds.legendGroup === dataset.legendGroup) {
                                            const meta = chart.getDatasetMeta(index);
                                            meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
                                        }
                                    });
                                } else {
                                    // Default behavior for individual sales datasets
                                    const meta = chart.getDatasetMeta(datasetIndex);
                                    meta.hidden = meta.hidden === null ? !chart.data.datasets[datasetIndex].hidden : null;
                                }
                                
                                chart.update();
                            },
                            labels: {
                                filter: function(legendItem, chartData) {
                                    // Only show one legend item per property type for trend lines
                                    const dataset = chartData.datasets[legendItem.datasetIndex];
                                    if (dataset.legendGroup && dataset.trendType === 'overall') {
                                        return false; // Hide overall trend from legend
                                    }
                                    return true;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'month',
                                displayFormats: {
                                    month: 'MMM yyyy'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: pricingType === 'per_sqm' ? 'Price per m² (AUD)' : 'Price (AUD)'
                            },
                            ticks: {
                                callback: function(value) {
                                    if (pricingType === 'per_sqm') {
                                        return '$' + Math.round(value).toLocaleString() + '/m²';
                                    } else {
                                        return '$' + value.toLocaleString();
                                    }
                                }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'nearest'
                    }
                }
            });
            
            // Calculate and display trend growth rate for RESIDENCE data
            const residenceData = dataByPropertyType['RESIDENCE'];
            if (residenceData && residenceData.length >= 3) {
                const selectedTrendType = document.querySelector('input[name="trendType"]:checked').value;
                const selectedTimeFrame = document.querySelector('input[name="trendTimeFrame"]:checked').value;
                
                let trendDataForGrowth;
                switch(selectedTrendType) {
                    case 'polynomial':
                        trendDataForGrowth = calculatePolynomialTrend(residenceData, selectedTimeFrame);
                        break;
                    case 'cagr':
                        trendDataForGrowth = calculateCAGRTrend(residenceData, selectedTimeFrame);
                        break;
                    case 'moving':
                        trendDataForGrowth = calculateMovingAverageTrend(residenceData, null);
                        break;
                    case 'smoothed':
                        trendDataForGrowth = calculateSmoothedTrend(residenceData, null);
                        break;
                    case 'linear':
                    default:
                        trendDataForGrowth = calculateLinearTrend(residenceData, selectedTimeFrame);
                        break;
                }
                
                const growthRate = calculateTrendGrowthRate(trendDataForGrowth, selectedTrendType, selectedTimeFrame);
                const growthDisplay = growthRate !== null ? 
                    (growthRate >= 0 ? '+' : '') + growthRate.toFixed(1) + '%' : 
                    'N/A';
                
                document.getElementById('trendGrowth').textContent = growthDisplay;
            } else {
                document.getElementById('trendGrowth').textContent = 'N/A';
            }
            
            document.getElementById('stats').style.display = 'grid';
        }

        function interpolateTrendForPeriod(periodData, linearTrendData) {
            if (linearTrendData.length < 2 || periodData.length === 0) return [];
            
            const [start, end] = linearTrendData;
            const slope = (end.y - start.y) / (end.x.getTime() - start.x.getTime());
            
            return periodData.map(point => ({
                x: point.x,
                y: start.y + slope * (point.x.getTime() - start.x.getTime())
            }));
        }


        function groupDataByPropertyType(data) {
            const grouped = {};
            const allowedTypes = ['RESIDENCE', 'VACANT LAND', 'COMMERCIAL'];
            
            data.forEach(item => {
                const propertyType = item.propertyType || 'Unknown';
                
                // Only include allowed property types
                if (allowedTypes.includes(propertyType)) {
                    if (!grouped[propertyType]) {
                        grouped[propertyType] = [];
                    }
                    grouped[propertyType].push(item);
                }
            });
            
            return grouped;
        }

        // Cache pricing mode to avoid repeated DOM queries
        let cachedPricingMode = null;
        
        function getCachedPricingMode() {
            if (cachedPricingMode === null) {
                cachedPricingMode = document.querySelector('input[name="pricingType"]:checked').value;
            }
            return cachedPricingMode;
        }
        
        function invalidatePricingCache() {
            cachedPricingMode = null;
        }
        
        function getPriceValue(item) {
            const pricingType = getCachedPricingMode();
            if (pricingType === 'per_sqm') {
                // Only return pricePerSqm if it exists and is valid
                return item._hasAreaData && item.pricePerSqm ? item.pricePerSqm : null;
            }
            return item.price;
        }

        function calculateLinearTrend(data, timeFrameYears = null) {
            if (data.length < 2) return [];
            
            // Filter data based on time frame if specified
            let filteredData = data;
            if (timeFrameYears && timeFrameYears !== 'all') {
                const cutoffDate = new Date();
                cutoffDate.setFullYear(cutoffDate.getFullYear() - parseInt(timeFrameYears));
                filteredData = data.filter(item => item.date >= cutoffDate);
            }
            
            if (filteredData.length < 2) return [];
            
            // Convert dates to numeric values (time in milliseconds) and filter out null price values
            const dataPoints = filteredData.map(item => ({
                x: item.date.getTime(),
                y: getPriceValue(item)
            })).filter(point => point.y !== null && point.y > 0); // Filter out null or zero prices
            
            if (dataPoints.length < 2) return []; // Need at least 2 valid points for trend
            
            // Calculate linear regression
            const n = dataPoints.length;
            const sumX = dataPoints.reduce((sum, point) => sum + point.x, 0);
            const sumY = dataPoints.reduce((sum, point) => sum + point.y, 0);
            const sumXY = dataPoints.reduce((sum, point) => sum + point.x * point.y, 0);
            const sumXX = dataPoints.reduce((sum, point) => sum + point.x * point.x, 0);
            
            // Calculate slope (m) and y-intercept (b) for y = mx + b
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Validate that we got valid slope and intercept
            if (!isFinite(slope) || !isFinite(intercept)) {
                console.log('Invalid trend calculation - slope or intercept is not finite');
                return [];
            }
            
            // Create trend line data points - extend across the full original data range
            const sortedOriginalData = [...data].sort((a, b) => a.date - b.date);
            const startDate = sortedOriginalData[0].date;
            const endDate = sortedOriginalData[sortedOriginalData.length - 1].date;
            
            // Extend the trend line slightly beyond the data range
            const timeRange = endDate.getTime() - startDate.getTime();
            const extendedStart = new Date(startDate.getTime() - timeRange * 0.05);
            const extendedEnd = new Date(endDate.getTime() + timeRange * 0.05);
            
            const startY = slope * extendedStart.getTime() + intercept;
            const endY = slope * extendedEnd.getTime() + intercept;
            
            return [
                {
                    x: extendedStart,
                    y: Math.max(0.1, startY) // Ensure positive values
                },
                {
                    x: extendedEnd,
                    y: Math.max(0.1, endY) // Ensure positive values
                }
            ];
        }

        function calculateCAGRTrend(data, timeFrameYears = null) {
            if (data.length < 2) return [];
            
            // Filter data based on time frame if specified
            let filteredData = data;
            if (timeFrameYears && timeFrameYears !== 'all') {
                const cutoffDate = new Date();
                cutoffDate.setFullYear(cutoffDate.getFullYear() - parseInt(timeFrameYears));
                filteredData = data.filter(item => item.date >= cutoffDate);
            }
            
            if (filteredData.length < 2) return [];
            
            // Sort data to get earliest and latest points with valid prices
            const validData = filteredData.filter(item => {
                const priceValue = getPriceValue(item);
                return priceValue !== null && priceValue > 0;
            });
            
            if (validData.length < 2) return [];
            
            const sortedData = [...validData].sort((a, b) => a.date - b.date);
            const startPoint = sortedData[0];
            const endPoint = sortedData[sortedData.length - 1];
            
            // Calculate CAGR and create a straight line
            const timeSpanMs = endPoint.date.getTime() - startPoint.date.getTime();
            const timeSpanYears = timeSpanMs / (1000 * 60 * 60 * 24 * 365.25);
            
            if (timeSpanYears <= 0) return [];
            
            const startPrice = getPriceValue(startPoint);
            const endPrice = getPriceValue(endPoint);
            
            if (!startPrice || !endPrice || startPrice <= 0 || endPrice <= 0) return [];
            
            const cagr = Math.pow(endPrice / startPrice, 1 / timeSpanYears);
            
            // Create trend line points from start to end based on CAGR
            return [
                {
                    x: startPoint.date,
                    y: getPriceValue(startPoint)
                },
                {
                    x: endPoint.date,
                    y: getPriceValue(endPoint)
                }
            ];
        }

        function calculatePolynomialTrend(data, timeFrameYears = null) {
            if (data.length < 5) return [];
            
            // Filter data based on time frame if specified
            let filteredData = data;
            if (timeFrameYears && timeFrameYears !== 'all') {
                const cutoffDate = new Date();
                cutoffDate.setFullYear(cutoffDate.getFullYear() - parseInt(timeFrameYears));
                filteredData = data.filter(item => item.date >= cutoffDate);
            }
            
            if (filteredData.length < 5) return [];
            
            // Use moving averages to create a smoother polynomial trend
            const sortedData = [...filteredData].sort((a, b) => a.date - b.date);
            const windowSize = Math.max(3, Math.floor(sortedData.length / 10));
            const smoothedPoints = [];
            
            // Create smoothed points using simple moving average
            for (let i = windowSize; i < sortedData.length - windowSize; i += windowSize) {
                const window = sortedData.slice(i - windowSize, i + windowSize);
                const avgPrice = window.reduce((sum, item) => sum + getPriceValue(item), 0) / window.length;
                smoothedPoints.push({
                    x: sortedData[i].date,
                    y: avgPrice
                });
            }
            
            if (smoothedPoints.length < 3) {
                // Fall back to linear if not enough points
                return calculateLinearTrend(data, timeFrameYears);
            }
            
            return smoothedPoints;
        }

        function calculateSmoothedTrend(data, timeFrameYears = null) {
            if (data.length < 6) return [];
            
            // Filter data based on time frame if specified
            let filteredData = data;
            if (timeFrameYears && timeFrameYears !== 'all') {
                const cutoffDate = new Date();
                cutoffDate.setFullYear(cutoffDate.getFullYear() - parseInt(timeFrameYears));
                filteredData = data.filter(item => item.date >= cutoffDate);
            }
            
            if (filteredData.length < 6) return [];
            
            // Simple exponential smoothing - much faster than LOWESS
            const sortedData = [...filteredData].sort((a, b) => a.date - b.date);
            const alpha = 0.3; // Smoothing factor
            const smoothed = [];
            
            // Initialize with first value
            let smoothedValue = getPriceValue(sortedData[0]);
            smoothed.push({
                x: sortedData[0].date,
                y: smoothedValue
            });
            
            // Apply exponential smoothing
            for (let i = 1; i < sortedData.length; i++) {
                smoothedValue = alpha * getPriceValue(sortedData[i]) + (1 - alpha) * smoothedValue;
                smoothed.push({
                    x: sortedData[i].date,
                    y: smoothedValue
                });
            }
            
            return smoothed;
        }

        function calculateMovingAverageTrend(data, timeFrameYears = null) {
            if (data.length < 12) return [];
            
            // Filter data based on time frame if specified
            let filteredData = data;
            if (timeFrameYears && timeFrameYears !== 'all') {
                const cutoffDate = new Date();
                cutoffDate.setFullYear(cutoffDate.getFullYear() - parseInt(timeFrameYears));
                filteredData = data.filter(item => item.date >= cutoffDate);
            }
            
            if (filteredData.length < 12) return [];
            
            // Sort by date and calculate rolling average
            const sortedData = [...filteredData].sort((a, b) => a.date - b.date);
            const windowSize = Math.min(12, Math.floor(sortedData.length / 8));
            const movingAvg = [];
            
            for (let i = windowSize - 1; i < sortedData.length; i++) {
                const window = sortedData.slice(i - windowSize + 1, i + 1);
                const avgPrice = window.reduce((sum, item) => sum + getPriceValue(item), 0) / window.length;
                
                movingAvg.push({
                    x: sortedData[i].date,
                    y: avgPrice
                });
            }
            
            return movingAvg;
        }

        function groupByQuarter(data) {
            const quarterlyGroups = {};
            
            data.forEach(item => {
                const year = item.date.getFullYear();
                const quarter = Math.floor(item.date.getMonth() / 3) + 1;
                const quarterKey = `${year}-Q${quarter}`;
                
                if (!quarterlyGroups[quarterKey]) {
                    quarterlyGroups[quarterKey] = [];
                }
                quarterlyGroups[quarterKey].push(getPriceValue(item));
            });
            
            return Object.keys(quarterlyGroups).map(quarterKey => {
                const [year, quarter] = quarterKey.split('-');
                const quarterNum = parseInt(quarter.substring(1));
                const prices = quarterlyGroups[quarterKey].sort((a, b) => a - b);
                const medianPrice = prices[Math.floor(prices.length / 2)];
                
                // Use middle month of quarter for x-axis positioning
                const middleMonth = (quarterNum - 1) * 3 + 1; // Q1=Jan(1), Q2=Apr(4), Q3=Jul(7), Q4=Oct(10)
                
                return {
                    x: new Date(parseInt(year), middleMonth, 15),
                    y: medianPrice
                };
            }).sort((a, b) => a.x - b.x);
        }

        function groupByYear(data) {
            const yearlyGroups = {};
            
            data.forEach(item => {
                const year = item.date.getFullYear();
                
                if (!yearlyGroups[year]) {
                    yearlyGroups[year] = [];
                }
                yearlyGroups[year].push(getPriceValue(item));
            });
            
            return Object.keys(yearlyGroups).map(year => {
                const prices = yearlyGroups[year].sort((a, b) => a - b);
                const medianPrice = prices[Math.floor(prices.length / 2)];
                
                return {
                    x: new Date(parseInt(year), 6, 1), // Use July 1st as mid-year point
                    y: medianPrice
                };
            }).sort((a, b) => a.x - b.x);
        }

        function groupByMonth(data) {
            const monthlyGroups = {};
            
            data.forEach(item => {
                const monthKey = `${item.date.getFullYear()}-${item.date.getMonth()}`;
                if (!monthlyGroups[monthKey]) {
                    monthlyGroups[monthKey] = [];
                }
                monthlyGroups[monthKey].push(getPriceValue(item));
            });
            
            return Object.keys(monthlyGroups).map(monthKey => {
                const [year, month] = monthKey.split('-').map(Number);
                const prices = monthlyGroups[monthKey].sort((a, b) => a - b);
                const medianPrice = prices[Math.floor(prices.length / 2)];
                
                return {
                    x: new Date(year, month, 15), // Use 15th of month
                    y: medianPrice
                };
            }).sort((a, b) => a.x - b.x);
        }

        function calculateTransactionVolume(data) {
            if (!data || data.length === 0) return [];
            
            const monthlyGroups = {};
            
            data.forEach(item => {
                const year = item.date.getFullYear();
                const month = item.date.getMonth(); // 0-based
                const key = `${year}-${String(month + 1).padStart(2, '0')}`;
                
                if (!monthlyGroups[key]) {
                    monthlyGroups[key] = 0;
                }
                monthlyGroups[key]++;
            });
            
            return Object.keys(monthlyGroups).map(key => {
                const [year, month] = key.split('-').map(Number);
                return {
                    x: new Date(year, month - 1, 15), // Use mid-month
                    y: monthlyGroups[key]
                };
            }).sort((a, b) => a.x - b.x);
        }

        function calculateTrendGrowthRate(trendData, selectedTrendType, selectedTimeFrame) {
            if (!trendData || trendData.length < 2) {
                console.log('Trend growth: insufficient data points', trendData?.length);
                return null;
            }
            
            let startValue, endValue, timeSpanYears;
            
            if (selectedTrendType === 'linear') {
                // For linear regression, calculate growth from trend line values at data endpoints
                const residenceData = window.currentLocalityData ? 
                    window.currentLocalityData.filter(item => item.propertyType === 'RESIDENCE') : [];
                
                if (residenceData.length < 2) {
                    console.log('Linear trend growth: insufficient residence data, found', residenceData.length, 'records');
                    console.log('Available property types:', window.currentLocalityData ? 
                        [...new Set(window.currentLocalityData.map(item => item.propertyType))] : 'No data');
                    return null;
                }
                
                let filteredData = residenceData;
                
                // Apply the same time filtering that was used to generate the trend
                if (selectedTimeFrame && selectedTimeFrame !== 'all') {
                    const years = parseInt(selectedTimeFrame);
                    const cutoffDate = new Date();
                    cutoffDate.setFullYear(cutoffDate.getFullYear() - years);
                    filteredData = residenceData.filter(item => item.date >= cutoffDate);
                }
                
                if (filteredData.length < 2) {
                    console.log('Linear trend growth: insufficient filtered data');
                    return null;
                }
                
                // Calculate the linear regression coefficients for the filtered data
                const dataPoints = filteredData.map(item => ({
                    x: item.date.getTime(),
                    y: item.price
                }));
                
                const n = dataPoints.length;
                const sumX = dataPoints.reduce((sum, point) => sum + point.x, 0);
                const sumY = dataPoints.reduce((sum, point) => sum + point.y, 0);
                const sumXY = dataPoints.reduce((sum, point) => sum + point.x * point.y, 0);
                const sumXX = dataPoints.reduce((sum, point) => sum + point.x * point.x, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                // Get the actual date range of the filtered data
                const sortedData = [...filteredData].sort((a, b) => a.date - b.date);
                const startDate = sortedData[0].date;
                const endDate = sortedData[sortedData.length - 1].date;
                
                // Calculate trend line values at these endpoints
                startValue = Math.max(1000, slope * startDate.getTime() + intercept);
                endValue = Math.max(1000, slope * endDate.getTime() + intercept);
                
                const timeSpanMs = endDate.getTime() - startDate.getTime();
                timeSpanYears = timeSpanMs / (1000 * 60 * 60 * 24 * 365.25);
                
                console.log('Linear trend growth calculation:', {
                    selectedTimeFrame,
                    dataPoints: n,
                    startDate,
                    endDate,
                    startValue,
                    endValue,
                    timeSpanYears,
                    slope,
                    expectedGrowth: ((endValue / startValue) ** (1 / timeSpanYears) - 1) * 100
                });
            } else if (selectedTrendType === 'cagr') {
                // For CAGR, use the trend data directly (start and end points)
                const sortedTrend = [...trendData].sort((a, b) => a.x.getTime() - b.x.getTime());
                startValue = sortedTrend[0].y;
                endValue = sortedTrend[sortedTrend.length - 1].y;
                
                const timeSpanMs = sortedTrend[sortedTrend.length - 1].x.getTime() - sortedTrend[0].x.getTime();
                timeSpanYears = timeSpanMs / (1000 * 60 * 60 * 24 * 365.25);
                
                console.log('CAGR trend growth calculation:', {
                    selectedTimeFrame,
                    startValue,
                    endValue,
                    timeSpanYears,
                    expectedGrowth: ((endValue / startValue) ** (1 / timeSpanYears) - 1) * 100
                });
            } else {
                // For other trend types, use actual data endpoints
                const sortedTrend = [...trendData].sort((a, b) => a.x.getTime() - b.x.getTime());
                
                // For time-based trends, use the specified timeframe
                if (selectedTimeFrame && selectedTimeFrame !== 'all') {
                    const years = parseInt(selectedTimeFrame);
                    const cutoffDate = new Date();
                    cutoffDate.setFullYear(cutoffDate.getFullYear() - years);
                    
                    const recentTrend = sortedTrend.filter(point => point.x >= cutoffDate);
                    if (recentTrend.length >= 2) {
                        startValue = recentTrend[0].y;
                        endValue = recentTrend[recentTrend.length - 1].y;
                        timeSpanYears = years;
                    } else {
                        return null;
                    }
                } else {
                    startValue = sortedTrend[0].y;
                    endValue = sortedTrend[sortedTrend.length - 1].y;
                    
                    const timeSpanMs = sortedTrend[sortedTrend.length - 1].x.getTime() - sortedTrend[0].x.getTime();
                    timeSpanYears = timeSpanMs / (1000 * 60 * 60 * 24 * 365.25);
                }
            }
            
            // Ensure we have valid values - be more lenient with validation
            if (timeSpanYears <= 0) {
                console.log('Trend growth validation failed: invalid time span', timeSpanYears);
                return null;
            }
            
            // Handle zero start value by using a small positive value
            if (startValue <= 0) {
                console.log('Adjusting zero start value to prevent division issues');
                startValue = Math.min(1000, endValue * 0.01); // Use 1% of end value or $1000, whichever is smaller
            }
            
            // Calculate compound annual growth rate (CAGR)
            const cagr = Math.pow(endValue / startValue, 1 / timeSpanYears) - 1;
            
            console.log('CAGR calculation:', {
                cagr,
                percentage: cagr * 100,
                isValid: !isNaN(cagr) && isFinite(cagr)
            });
            
            // Sanity check for reasonable values - be more lenient
            if (isNaN(cagr) || !isFinite(cagr)) {
                return null;
            }
            
            return cagr * 100; // Convert to percentage
        }

        function displayVolumeChart(data, locality) {
            const ctx = document.getElementById('volumeChart').getContext('2d');
            
            if (volumeChart) {
                volumeChart.destroy();
            }
            
            // Calculate transaction volume by month
            const volumeData = calculateTransactionVolume(data);
            
            // Create volume chart
            volumeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    datasets: [{
                        label: 'Monthly Transaction Volume',
                        data: volumeData,
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'year',
                                displayFormats: {
                                    year: 'yyyy'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Transactions'
                            },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Transaction Volume in ${locality.toUpperCase()} (Monthly)`
                        },
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        function displayStreetChart(data, locality) {
            console.log('displayStreetChart called with data length:', data.length);
            const pricingType = getCachedPricingMode();
            console.log('Pricing type:', pricingType);
            
            // Always show street chart container
            document.getElementById('streetChart').parentElement.style.display = 'block';
            
            // Filter to last 2 years
            const cutoffDate = new Date();
            cutoffDate.setFullYear(cutoffDate.getFullYear() - 2);
            console.log('Cutoff date:', cutoffDate);
            
            let recentData;
            if (pricingType === 'per_sqm') {
                // For per sqm mode, filter to properties with area data
                recentData = data.filter(item => 
                    item.date >= cutoffDate && 
                    item._hasAreaData && 
                    item.pricePerSqm &&
                    item.pricePerSqm > 0
                );
            } else {
                // For total price mode, use all recent data
                recentData = data.filter(item => item.date >= cutoffDate);
            }
            
            console.log('Recent data length:', recentData.length);
            
            if (recentData.length === 0) {
                console.log('No recent data available');
                const ctx = document.getElementById('streetChart').getContext('2d');
                if (streetChart) {
                    streetChart.destroy();
                }
                console.log('No recent street data available for analysis');
                return;
            }
            
            // Split by property type first
            const residentialData = recentData.filter(item => item.propertyType === 'RESIDENCE');
            const landData = recentData.filter(item => item.propertyType === 'VACANT LAND');
            
            console.log('Property type counts:', { residential: residentialData.length, land: landData.length, other: recentData.length - residentialData.length - landData.length });
            
            // Choose the larger dataset for the primary analysis, or residential if both are small
            const primaryData = residentialData.length >= landData.length ? residentialData : landData;
            const primaryType = residentialData.length >= landData.length ? 'RESIDENCE' : 'VACANT LAND';
            
            // Use residential data if available, otherwise fall back to land
            const analysisData = residentialData.length >= 3 ? residentialData : 
                                landData.length >= 3 ? landData : recentData;
            const analysisType = residentialData.length >= 3 ? 'RESIDENCE' : 
                               landData.length >= 3 ? 'VACANT LAND' : 'ALL PROPERTIES';
            
            console.log('Analysis decision:', { type: analysisType, dataLength: analysisData.length });
            
            if (analysisData.length === 0) {
                console.log('No analysis data available');
                const ctx = document.getElementById('streetChart').getContext('2d');
                if (streetChart) {
                    streetChart.destroy();
                }
                console.log('No street data available for analysis');
                return;
            }
            
            // Group by street name for the chosen property type
            const streetGroups = {};
            
            // Group priced properties for average calculations
            analysisData.forEach(item => {
                const street = item.streetName || 'Unknown Street';
                
                if (!streetGroups[street]) {
                    streetGroups[street] = [];
                }
                
                // Use appropriate price value based on mode
                const priceValue = pricingType === 'per_sqm' ? item.pricePerSqm : item.price;
                streetGroups[street].push(priceValue);
            });
            
            console.log('Street groups created:', Object.keys(streetGroups).length, 'streets');
            console.log('Streets found:', Object.keys(streetGroups));
            
            // Calculate average price per sqm for each street
            let streetStats = Object.entries(streetGroups)
                .map(([street, prices]) => ({
                    street: street,
                    avgPrice: prices.reduce((sum, p) => sum + p, 0) / prices.length,
                    count: prices.length
                }))
                .filter(street => street.count >= 3) // Only streets with 3+ sales for better quality
                .sort((a, b) => a.avgPrice - b.avgPrice); // Sort by price (lowest first)
            
            console.log('Street stats after filtering (3+ sales):', streetStats.length);
            
            if (streetStats.length === 0) {
                console.log('No streets with sufficient sales data (3+ sales required)');
                // Try with 2+ sales minimum
                streetStats = Object.entries(streetGroups)
                    .map(([street, prices]) => ({
                        street: street,
                        avgPrice: prices.reduce((sum, p) => sum + p, 0) / prices.length,
                        count: prices.length
                    }))
                    .filter(street => street.count >= 2) // Only streets with 2+ sales
                    .sort((a, b) => a.avgPrice - b.avgPrice);
                    
                console.log('Trying with 2+ sales minimum:', streetStats.length);
                
                if (streetStats.length === 0) {
                    return;
                }
            }
            
            // Limit to top 20 streets for readability (10 cheapest + 10 most expensive)
            let cheapestStreets = [];
            let expensiveStreets = [];
            
            if (streetStats.length > 20) {
                cheapestStreets = streetStats.slice(0, 10);
                expensiveStreets = streetStats.slice(-10);
                console.log('Split into cheapest and most expensive streets for readability');
            } else if (streetStats.length > 10) {
                // If between 10-20 streets, split them roughly in half
                const midPoint = Math.ceil(streetStats.length / 2);
                cheapestStreets = streetStats.slice(0, midPoint);
                expensiveStreets = streetStats.slice(midPoint);
            } else {
                // If 10 or fewer streets, show all in the first chart
                cheapestStreets = streetStats;
                expensiveStreets = [];
            }
            
            // Calculate suburb average
            const allPrices = Object.values(streetGroups).flat();
            const suburbAvg = allPrices.reduce((sum, p) => sum + p, 0) / allPrices.length;
            
            // Set appropriate labels based on pricing mode and property type (shared by both charts)
            const priceLabel = pricingType === 'per_sqm' ? 'Price per m²' : 'Total Price';
            const typeLabel = analysisType === 'ALL PROPERTIES' ? '' : ` - ${analysisType}`;
            const yAxisLabel = pricingType === 'per_sqm' ? 'Price Per Square Meter ($)' : 'Price ($)';
            const avgLabel = pricingType === 'per_sqm' ? 
                `$${Math.round(suburbAvg).toLocaleString()}/m²` : 
                `$${Math.round(suburbAvg).toLocaleString()}`;
            
            // Create first chart for cheapest streets
            if (cheapestStreets.length > 0) {
                const labels = cheapestStreets.map(s => `${s.street} (${s.count})`);
                const prices = cheapestStreets.map(s => s.avgPrice);
                const percentages = cheapestStreets.map(s => ((s.avgPrice - suburbAvg) / suburbAvg * 100));
                
                // Color code: red for below average, green for above average
                const backgroundColors = percentages.map(pct => 
                    pct < 0 ? 'rgba(255, 99, 132, 0.7)' : 'rgba(75, 192, 192, 0.7)'
                );
                const borderColors = percentages.map(pct => 
                    pct < 0 ? 'rgba(255, 99, 132, 1)' : 'rgba(75, 192, 192, 1)'
                );
                
                const chartTitle = `${locality.replace(/_/g, ' ')}: Cheapest Streets - ${priceLabel} (Last 2 Years)${typeLabel}`;
                
                console.log(`Street analysis: Using ${analysisData.length} ${analysisType} properties from ${Object.keys(streetGroups).length} streets`);
                console.log(`Property type breakdown: ${residentialData.length} RESIDENCE, ${landData.length} VACANT LAND, ${recentData.length - residentialData.length - landData.length} other types`);
                
                if (streetChart) {
                    streetChart.destroy();
                }
                
                console.log('Creating cheapest streets chart with data:', { streets: cheapestStreets.length, prices: prices.slice(0, 5) });
                
                const ctx = document.getElementById('streetChart').getContext('2d');
                try {
                streetChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: priceLabel,
                        data: prices,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y', // Horizontal bars
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: chartTitle,
                            font: {
                                size: 14
                            }
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const price = pricingType === 'per_sqm' ? 
                                        '$' + Math.round(context.parsed.x).toLocaleString() + '/m²' :
                                        '$' + context.parsed.x.toLocaleString();
                                    const pct = percentages[context.dataIndex];
                                    const direction = pct >= 0 ? 'above' : 'below';
                                    return [`${price}`, `${Math.abs(pct).toFixed(1)}% ${direction} suburb average (${avgLabel})`];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: yAxisLabel
                            },
                            ticks: {
                                callback: function(value) {
                                    if (pricingType === 'per_sqm') {
                                        return '$' + Math.round(value).toLocaleString();
                                    } else {
                                        return '$' + value.toLocaleString();
                                    }
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Street'
                            },
                            ticks: {
                                font: {
                                    size: 10
                                },
                                maxRotation: 0
                            }
                        }
                    },
                    // Custom plugin to add percentage labels
                    interaction: {
                        intersect: false,
                        mode: 'nearest'
                    }
                },
                plugins: [{
                    id: 'customLabels',
                    afterDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        ctx.save();
                        ctx.font = '11px Arial';
                        ctx.fillStyle = 'black';
                        ctx.textAlign = 'left';
                        
                        chart.data.datasets[0].data.forEach((value, index) => {
                            const meta = chart.getDatasetMeta(0);
                            const bar = meta.data[index];
                            const pct = percentages[index];
                            let label;
                            
                            if (pricingType === 'per_sqm') {
                                label = `$${Math.round(value).toLocaleString()} (${pct > 0 ? '+' : ''}${pct.toFixed(1)}%)`;
                            } else {
                                label = `$${Math.round(value).toLocaleString()} (${pct > 0 ? '+' : ''}${pct.toFixed(1)}%)`;
                            }
                            
                            // Position label to the right of the bar
                            ctx.fillText(label, bar.x + 10, bar.y + 5);
                        });
                        
                        ctx.restore();
                    }
                }]
            });
            console.log('Cheapest streets chart created successfully');
            } catch (error) {
                console.error('Error creating cheapest streets chart:', error);
            }
        }

        // Create the second chart showing most expensive streets  
            if (expensiveStreets.length > 0) {
                try {
                    if (streetCountChart) {
                        streetCountChart.destroy();
                    }
                    
                    const expensiveLabels = expensiveStreets.map(s => `${s.street} (${s.count})`);
                    const expensivePrices = expensiveStreets.map(s => s.avgPrice);
                    const expensivePercentages = expensiveStreets.map(s => ((s.avgPrice - suburbAvg) / suburbAvg * 100));
                    
                    // Color code: red for below average, green for above average  
                    const expensiveBackgroundColors = expensivePercentages.map(pct => 
                        pct < 0 ? 'rgba(255, 99, 132, 0.7)' : 'rgba(75, 192, 192, 0.7)'
                    );
                    const expensiveBorderColors = expensivePercentages.map(pct => 
                        pct < 0 ? 'rgba(255, 99, 132, 1)' : 'rgba(75, 192, 192, 1)'
                    );
                    
                    const expensiveChartTitle = `${locality.replace(/_/g, ' ')}: Most Expensive Streets - ${priceLabel} (Last 2 Years)${typeLabel}`;
                    
                    const expensiveCtx = document.getElementById('streetCountChart').getContext('2d');
                    
                    streetCountChart = new Chart(expensiveCtx, {
                        type: 'bar',
                        data: {
                            labels: expensiveLabels,
                            datasets: [{
                                label: priceLabel,
                                data: expensivePrices,
                                backgroundColor: expensiveBackgroundColors,
                                borderColor: expensiveBorderColors,
                                borderWidth: 1
                            }]
                        },
                        options: {
                            indexAxis: 'y', // Horizontal bars
                            responsive: true,
                            maintainAspectRatio: false,
                            layout: {
                                padding: {
                                    left: 10,
                                    right: 50
                                }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: expensiveChartTitle,
                                    font: {
                                        size: 14
                                    }
                                },
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const price = pricingType === 'per_sqm' ? 
                                                '$' + Math.round(context.parsed.x).toLocaleString() + '/m²' :
                                                '$' + context.parsed.x.toLocaleString();
                                            const pct = expensivePercentages[context.dataIndex];
                                            const direction = pct >= 0 ? 'above' : 'below';
                                            return [`${price}`, `${Math.abs(pct).toFixed(1)}% ${direction} suburb average (${avgLabel})`];
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: yAxisLabel
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            if (pricingType === 'per_sqm') {
                                                return '$' + Math.round(value).toLocaleString();
                                            } else {
                                                return '$' + value.toLocaleString();
                                            }
                                        }
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Street'
                                    },
                                    ticks: {
                                        font: {
                                            size: 10
                                        },
                                        maxRotation: 0
                                    }
                                }
                            },
                            // Custom plugin to add percentage labels
                            interaction: {
                                intersect: false,
                                mode: 'nearest'
                            }
                        },
                        plugins: [{
                            id: 'expensiveLabels',
                            afterDatasetsDraw: function(chart) {
                                const ctx = chart.ctx;
                                ctx.save();
                                
                                ctx.font = '12px Arial';
                                ctx.fillStyle = '#333';
                                ctx.textAlign = 'left';
                                
                                chart.data.datasets[0].data.forEach((value, index) => {
                                    const bar = chart.getDatasetMeta(0).data[index];
                                    const pct = expensivePercentages[index];
                                    
                                    let label;
                                    
                                    if (pricingType === 'per_sqm') {
                                        label = `$${Math.round(value).toLocaleString()} (${pct > 0 ? '+' : ''}${pct.toFixed(1)}%)`;
                                    } else {
                                        label = `$${Math.round(value).toLocaleString()} (${pct > 0 ? '+' : ''}${pct.toFixed(1)}%)`;
                                    }
                                    
                                    // Position label to the right of the bar
                                    ctx.fillText(label, bar.x + 10, bar.y + 5);
                                });
                                
                                ctx.restore();
                            }
                        }]
                    });
                    console.log('Most expensive streets chart created successfully');
                } catch (error) {
                    console.error('Error creating most expensive streets chart:', error);
                }
            } else {
                // If no expensive streets to show, hide the second chart
                if (streetCountChart) {
                    streetCountChart.destroy();
                }
                console.log('No expensive streets to display in second chart');
            }
        }

        function updateStats(data, outliersRemoved = 0) {
            const pricingType = getCachedPricingMode();
            
            // Filter data for price per sqm mode if needed (reuse filter logic)
            let statsData = data;
            if (pricingType === 'per_sqm') {
                statsData = data.filter(item => item._hasAreaData);
            }
            
            const totalSales = statsData.length;
            
            // Get latest 100 records for average and median
            const sortedData = [...statsData].sort((a, b) => b.date - a.date);
            const latestRecords = sortedData.slice(0, Math.min(100, statsData.length));
            
            let avgPrice, medianPrice;
            if (latestRecords.length > 0) {
                // Optimize: extract prices once and reuse
                const latestPrices = latestRecords.map(item => getPriceValue(item));
                avgPrice = latestPrices.reduce((sum, price) => sum + price, 0) / latestPrices.length;
                const sortedLatestPrices = [...latestPrices].sort((a, b) => a - b);
                medianPrice = sortedLatestPrices[Math.floor(sortedLatestPrices.length / 2)];
                
                // Reuse sorted prices for min/max instead of mapping again
                const minPrice = sortedLatestPrices[0];
                const maxPrice = sortedLatestPrices[sortedLatestPrices.length - 1];
                
                // Update display
                const priceSuffix = pricingType === 'per_sqm' ? '/m²' : '';
                document.getElementById('totalSales').textContent = totalSales.toLocaleString();
                document.getElementById('avgPrice').textContent = '$' + Math.round(avgPrice).toLocaleString() + priceSuffix;
                document.getElementById('medianPrice').textContent = '$' + Math.round(medianPrice).toLocaleString() + priceSuffix;
                document.getElementById('priceRange').textContent = 
                    '$' + Math.round(minPrice).toLocaleString() + priceSuffix + ' - $' + Math.round(maxPrice).toLocaleString() + priceSuffix;
            } else {
                // Fallback to all data if somehow no records
                const allPrices = statsData.map(item => getPriceValue(item));
                avgPrice = allPrices.reduce((sum, price) => sum + price, 0) / allPrices.length;
                const sortedAllPrices = [...allPrices].sort((a, b) => a - b);
                medianPrice = sortedAllPrices[Math.floor(sortedAllPrices.length / 2)];
                
                const priceSuffix = pricingType === 'per_sqm' ? '/m²' : '';
                document.getElementById('avgPrice').textContent = '$' + Math.round(avgPrice).toLocaleString() + priceSuffix;
                document.getElementById('medianPrice').textContent = '$' + Math.round(medianPrice).toLocaleString() + priceSuffix;
                document.getElementById('priceRange').textContent = 
                    '$' + Math.round(sortedAllPrices[0]).toLocaleString() + priceSuffix + ' - $' + Math.round(sortedAllPrices[sortedAllPrices.length - 1]).toLocaleString() + priceSuffix;
            }
            
            // Count property types
            const propertyTypes = {};
            data.forEach(item => {
                if (item.propertyType) {
                    propertyTypes[item.propertyType] = (propertyTypes[item.propertyType] || 0) + 1;
                }
            });
            
            const topPropertyTypes = Object.entries(propertyTypes)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .map(([type, count]) => `<div class="stat-value property-types"><strong>${type}</strong><br><small>(${count} sales)</small></div>`)
                .join('');
            
            document.getElementById('outliersRemoved').textContent = outliersRemoved.toLocaleString();
            document.getElementById('propertyTypes').innerHTML = topPropertyTypes || '<div class="stat-value property-types">Unknown</div>';
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        function hideChart() {
            if (chart) {
                chart.destroy();
                chart = null;
            }
            if (volumeChart) {
                volumeChart.destroy();
                volumeChart = null;
            }
            document.getElementById('stats').style.display = 'none';
        }
    </script>
</body>
</html>