<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NSW Property Sales Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .controls {
            margin-bottom: 30px;
            text-align: center;
        }
        select {
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            min-width: 250px;
        }
        .loading {
            text-align: center;
            color: #666;
            margin: 20px 0;
            display: none;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .stat-card {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .stat-card.property-types-card {
            grid-column: span 2;
            text-align: left;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: center;
            min-height: 60px;
        }
        .stat-value.property-types {
            font-size: 12px;
            line-height: 1.2;
            color: #495057;
            margin: 0 10px;
            text-align: center;
        }
        .stat-label {
            color: #666;
            margin-top: 5px;
        }
        .chart-container {
            position: relative;
            height: 500px;
            margin-top: 20px;
        }
        .error {
            color: #dc3545;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 4px;
            margin: 20px 0;
            display: none;
        }
        .attribution {
            margin-top: 40px;
            padding: 20px;
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
            border-radius: 4px;
        }
        .attribution h3 {
            margin-top: 0;
            color: #333;
            font-size: 18px;
        }
        .attribution p {
            margin: 8px 0;
            color: #555;
            line-height: 1.4;
        }
        .attribution a {
            color: #007bff;
            text-decoration: none;
        }
        .attribution a:hover {
            text-decoration: underline;
        }
        .attribution em {
            font-style: italic;
            color: #666;
            font-size: 14px;
        }
        .source-code {
            margin-top: 20px;
            text-align: center;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        .source-code p {
            margin: 0;
            color: #555;
        }
        .source-code a {
            color: #007bff;
            text-decoration: none;
            font-weight: normal;
        }
        .source-code a:hover {
            text-decoration: underline;
        }
        input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        input:disabled + label {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .tooltip {
            position: absolute;
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 250px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            line-height: 1.3;
        }
        .tooltip.show {
            opacity: 1;
        }
        .trend-type-label {
            position: relative;
            cursor: help;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>NSW Property Sales Analyzer</h1>
        
        <div class="controls">
            <label for="localitySelect">Select a Locality:</label>
            <select id="localitySelect">
                <option value="">Loading localities...</option>
            </select>
            
            <div style="margin-top: 15px;">
                <label>
                    <input type="checkbox" id="showIndividualSales">
                    Show Individual Purchases
                </label>
            </div>
            
            <div style="margin-top: 15px;">
                <label>Trend Period:</label><br>
                <label><input type="radio" name="trendPeriod" value="monthly"> Monthly</label>
                <label style="margin-left: 15px;"><input type="radio" name="trendPeriod" value="quarterly"> Quarterly</label>
                <label style="margin-left: 15px;"><input type="radio" name="trendPeriod" value="yearly" checked> Yearly</label>
            </div>
            
            <div style="margin-top: 15px;">
                <label>Long-term Trend Type:</label><br>
                <label class="trend-type-label" data-tooltip="Straight line through data points using mathematical regression. Good for identifying consistent long-term growth or decline patterns."><input type="radio" name="trendType" value="linear" checked> Linear Regression</label>
                <label class="trend-type-label" style="margin-left: 15px;" data-tooltip="Simple compound annual growth rate line from earliest to latest data point. Shows the constant growth rate needed to reach current levels."><input type="radio" name="trendType" value="cagr"> CAGR Line</label>
                <label class="trend-type-label" style="margin-left: 15px;" data-tooltip="Curved trend line using moving averages to create smooth patterns. Shows gentle market cycles and turning points."><input type="radio" name="trendType" value="polynomial"> Polynomial (Curved)</label>
                <label class="trend-type-label" style="margin-left: 15px;" data-tooltip="Rolling average that smooths out short-term noise. Follows market movements closely while reducing volatility spikes."><input type="radio" name="trendType" value="moving"> Moving Average</label>
                <label class="trend-type-label" style="margin-left: 15px;" data-tooltip="Exponential smoothing that adapts to recent trends. Reacts quickly to market changes while maintaining smooth progression."><input type="radio" name="trendType" value="smoothed"> Smoothed</label>
            </div>
            
            <div style="margin-top: 15px;">
                <label>Long-term Trend Based On:</label><br>
                <label><input type="radio" name="trendTimeFrame" value="all"> All Data</label>
                <label style="margin-left: 15px;"><input type="radio" name="trendTimeFrame" value="5"> Last 5 Years</label>
                <label style="margin-left: 15px;"><input type="radio" name="trendTimeFrame" value="10"> Last 10 Years</label>
                <label style="margin-left: 15px;"><input type="radio" name="trendTimeFrame" value="15" checked> Last 15 Years</label>
            </div>
        </div>
        
        <div class="loading" id="loading">Loading property data...</div>
        <div class="error" id="error"></div>
        
        <div class="stats" id="stats" style="display: none;">
            <div class="stat-card">
                <div class="stat-value" id="totalSales">0</div>
                <div class="stat-label">Total Sales</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgPrice">$0</div>
                <div class="stat-label">Latest 100 Avg Price</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="medianPrice">$0</div>
                <div class="stat-label">Latest 100 Median Price</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="priceRange">$0</div>
                <div class="stat-label">Price Range</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="outliersRemoved">0</div>
                <div class="stat-label">Outliers Removed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="trendGrowth">-</div>
                <div class="stat-label">Trend Growth (% p.a.)</div>
            </div>
            <div class="stat-card property-types-card">
                <div class="stat-label" style="width: 100%; margin-bottom: 10px; text-align: center;">Property Types</div>
                <div id="propertyTypes" style="display: flex; flex-wrap: wrap; justify-content: space-around; width: 100%;">-</div>
            </div>
        </div>
        
        <div class="chart-container">
            <canvas id="priceChart"></canvas>
        </div>
        
        <div class="chart-container" style="margin-top: 20px; height: 300px;">
            <canvas id="volumeChart"></canvas>
        </div>
        
        <div class="attribution">
            <h3>Data Source</h3>
            <p>This analysis uses NSW Valuer General's Bulk Property Sales Information, acquired on 16th January 2026.</p>
            <p>The data is licensed under a Creative Commons license and can be downloaded from:</p>
            <p><a href="https://valuation.property.nsw.gov.au/embed/propertySalesInformation" target="_blank">NSW Valuer General - Property Sales Information</a></p>
        </div>
        
        <div class="source-code">
            <p><strong>Source Code:</strong> <a href="https://github.com/reductor/nswproperty" target="_blank">GitHub Repository</a></p>
        </div>
    </div>

    <script>
        let chart = null;
        let volumeChart = null;
        let localities = [];

        // Load localities on page load
        window.addEventListener('load', loadLocalities);

        async function loadLocalities() {
            try {
                const response = await fetch('localities.json');
                localities = await response.json();
                
                const select = document.getElementById('localitySelect');
                select.innerHTML = '<option value="">Select a locality...</option>';
                
                localities.forEach(locality => {
                    const option = document.createElement('option');
                    option.value = locality;
                    option.textContent = locality.replace(/_/g, ' ');
                    select.appendChild(option);
                });
                
                select.addEventListener('change', handleLocalityChange);
                
                // Check URL for locality parameter and restore selection
                const urlParams = new URLSearchParams(window.location.search);
                const localityFromUrl = urlParams.get('locality');
                if (localityFromUrl && localities.includes(localityFromUrl)) {
                    select.value = localityFromUrl;
                    // Trigger the change event to load the data
                    const event = new Event('change');
                    select.dispatchEvent(event);
                }
                
            } catch (error) {
                showError('Failed to load localities: ' + error.message);
            }
        }

        async function handleLocalityChange(event) {
            const selectedLocality = event.target.value;
            
            // Update URL with selected locality
            updateURL(selectedLocality);
            
            if (!selectedLocality) {
                hideChart();
                return;
            }
            
            showLoading(true);
            hideError();
            
            try {
                const datFile = `localities/${selectedLocality}.DAT`;
                const response = await fetch(datFile);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${datFile}`);
                }
                
                const content = await response.text();
                const result = parsePropertyData(content);
                
                if (result.data.length === 0) {
                    throw new Error('No property data found in the selected locality');
                }
                
                displayChart(result.data, selectedLocality);
                displayVolumeChart(result.data, selectedLocality);
                updateStats(result.data, result.outliersRemoved);
                
                // Setup event listeners
                const checkbox = document.getElementById('showIndividualSales');
                const trendPeriodRadios = document.querySelectorAll('input[name="trendPeriod"]');
                const trendTimeFrameRadios = document.querySelectorAll('input[name="trendTimeFrame"]');
                const trendTypeRadios = document.querySelectorAll('input[name="trendType"]');
                
                checkbox.onchange = () => {
                    displayChart(result.data, selectedLocality);
                };
                
                trendPeriodRadios.forEach(radio => {
                    radio.onchange = () => {
                        displayChart(result.data, selectedLocality);
                    };
                });
                
                trendTimeFrameRadios.forEach(radio => {
                    radio.onchange = () => {
                        displayChart(result.data, selectedLocality);
                    };
                });
                
                trendTypeRadios.forEach(radio => {
                    radio.onchange = () => {
                        updateTimeFrameControls();
                        displayChart(result.data, selectedLocality);
                    };
                });
                
                // Set initial state of time frame controls
                updateTimeFrameControls();
                
                // Setup tooltips for trend type labels
                setupTooltips();
                
                function updateTimeFrameControls() {
                    const selectedTrendType = document.querySelector('input[name="trendType"]:checked').value;
                    const isRegressionBased = selectedTrendType === 'linear' || selectedTrendType === 'polynomial' || selectedTrendType === 'cagr';
                    const timeFrameRadios = document.querySelectorAll('input[name="trendTimeFrame"]');
                    
                    timeFrameRadios.forEach(tfRadio => {
                        tfRadio.disabled = !isRegressionBased;
                        // Find the label for this radio button and update its style
                        const label = tfRadio.parentElement;
                        if (label && label.tagName === 'LABEL') {
                            label.style.opacity = isRegressionBased ? '1' : '0.5';
                            label.style.cursor = isRegressionBased ? 'pointer' : 'not-allowed';
                        }
                    });
                }
                
                function setupTooltips() {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';
                    document.body.appendChild(tooltip);
                    
                    const trendLabels = document.querySelectorAll('.trend-type-label');
                    
                    trendLabels.forEach(label => {
                        label.addEventListener('mouseenter', (e) => {
                            const tooltipText = e.target.getAttribute('data-tooltip');
                            if (tooltipText) {
                                tooltip.textContent = tooltipText;
                                tooltip.classList.add('show');
                                
                                // Position tooltip near the element, accounting for scroll
                                const rect = e.target.getBoundingClientRect();
                                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                                const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                                
                                tooltip.style.left = (rect.left + scrollLeft + rect.width / 2 - tooltip.offsetWidth / 2) + 'px';
                                tooltip.style.top = (rect.bottom + scrollTop + 10) + 'px';
                            }
                        });
                        
                        label.addEventListener('mouseleave', (e) => {
                            // Add a small delay to prevent flickering
                            setTimeout(() => {
                                // Check if mouse is not over the tooltip
                                if (!tooltip.matches(':hover') && !e.target.matches(':hover')) {
                                    tooltip.classList.remove('show');
                                }
                            }, 100);
                        });
                        
                        label.addEventListener('mousemove', (e) => {
                            // Only update position if tooltip is visible
                            if (tooltip.classList.contains('show')) {
                                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                                const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                                
                                tooltip.style.left = (e.clientX + scrollLeft - tooltip.offsetWidth / 2) + 'px';
                                tooltip.style.top = (e.clientY + scrollTop + 15) + 'px';
                            }
                        });
                    });
                    
                    // Also hide tooltip when mouse leaves the tooltip itself
                    tooltip.addEventListener('mouseleave', () => {
                        tooltip.classList.remove('show');
                    });
                }
                
            } catch (error) {
                showError('Failed to load property data: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        function updateURL(locality) {
            const url = new URL(window.location);
            if (locality) {
                url.searchParams.set('locality', locality);
            } else {
                url.searchParams.delete('locality');
            }
            // Update URL without reloading the page
            window.history.replaceState({}, '', url);
        }

        function parsePropertyData(content) {
            const lines = content.split('\n');
            const properties = [];
            
            for (const line of lines) {
                if (line.trim().startsWith('B;')) {
                    const fields = line.split(';');
                    
                    if (fields.length >= 19) {
                        const dateStr = fields[14].trim(); // Field 15 (0-indexed as 14)
                        const priceStr = fields[15].trim(); // Field 16 (0-indexed as 15)
                        const propertyType = fields[18].trim(); // Field 19 (0-indexed as 18)
                        
                        if (dateStr && priceStr && priceStr !== '0' && !isNaN(priceStr)) {
                            const date = parseDate(dateStr);
                            const price = parseInt(priceStr);
                            
                            // Only include data from 2002 onwards and reasonable price range
                            if (date && price > 10000 && price < 100000000 && date.getFullYear() >= 1990) {
                                properties.push({ date, price, propertyType });
                            }
                        }
                    }
                }
            }
            
            // Filter outliers using IQR method
            const originalCount = properties.length;
            const filteredProperties = filterOutliers(properties);
            const outliersRemoved = originalCount - filteredProperties.length;
            
            // Sort by date
            const sortedData = filteredProperties.sort((a, b) => a.date - b.date);
            
            return {
                data: sortedData,
                outliersRemoved: outliersRemoved
            };
        }

        function filterOutliers(data) {
            if (data.length < 4) return data; // Need at least 4 data points for IQR
            
            const prices = data.map(item => item.price).sort((a, b) => a - b);
            const q1Index = Math.floor(prices.length * 0.25);
            const q3Index = Math.floor(prices.length * 0.75);
            const q1 = prices[q1Index];
            const q3 = prices[q3Index];
            const iqr = q3 - q1;
            
            // More aggressive filtering for low outliers, standard for high outliers
            const lowerBound = Math.max(10000, q1 - 0.5 * iqr); // Minimum $10,000 and less aggressive IQR
            const upperBound = q3 + 1.5 * iqr;
            
            // Filter out outliers
            const filtered = data.filter(item => 
                item.price >= lowerBound && item.price <= upperBound
            );
            
            console.log(`Original data points: ${data.length}, After outlier removal: ${filtered.length}`);
            console.log(`Price range: $${lowerBound.toLocaleString()} - $${upperBound.toLocaleString()}`);
            
            return filtered;
        }

        function parseDate(dateStr) {
            if (dateStr.length !== 8) return null;
            
            const year = parseInt(dateStr.substring(0, 4));
            const month = parseInt(dateStr.substring(4, 6)) - 1; // Month is 0-indexed
            const day = parseInt(dateStr.substring(6, 8));
            
            const date = new Date(year, month, day);
            return isNaN(date.getTime()) ? null : date;
        }

        function displayChart(data, locality) {
            // Store data globally for growth rate calculations
            window.currentLocalityData = data;
            
            const ctx = document.getElementById('priceChart').getContext('2d');
            
            if (chart) {
                chart.destroy();
            }
            
            const showIndividual = document.getElementById('showIndividualSales').checked;
            
            // Group data by property type
            const dataByPropertyType = groupDataByPropertyType(data);
            const propertyTypes = Object.keys(dataByPropertyType);
            
            const datasets = [];
            
            // Define colors for different property types
            const colors = [
                { bg: 'rgba(255, 99, 132, 0.6)', border: 'rgba(255, 99, 132, 1)' },
                { bg: 'rgba(54, 162, 235, 0.6)', border: 'rgba(54, 162, 235, 1)' },
                { bg: 'rgba(75, 192, 192, 0.6)', border: 'rgba(75, 192, 192, 1)' },
                { bg: 'rgba(255, 206, 86, 0.6)', border: 'rgba(255, 206, 86, 1)' },
                { bg: 'rgba(153, 102, 255, 0.6)', border: 'rgba(153, 102, 255, 1)' },
                { bg: 'rgba(255, 159, 64, 0.6)', border: 'rgba(255, 159, 64, 1)' },
                { bg: 'rgba(199, 199, 199, 0.6)', border: 'rgba(199, 199, 199, 1)' },
                { bg: 'rgba(83, 102, 255, 0.6)', border: 'rgba(83, 102, 255, 1)' }
            ];
            
            // Add individual sales datasets if checkbox is checked
            if (showIndividual) {
                propertyTypes.forEach((propertyType, index) => {
                    const typeData = dataByPropertyType[propertyType];
                    const color = colors[index % colors.length];
                    
                    datasets.push({
                        label: `${propertyType || 'Unknown'} Sales`,
                        data: typeData.map(item => ({ x: item.date, y: item.price })),
                        backgroundColor: color.bg,
                        borderColor: color.border,
                        borderWidth: 1,
                        pointRadius: 3,
                        hidden: propertyType === 'VACANT LAND' || propertyType === 'COMMERCIAL'
                    });
                });
            }
            
            // Add trend lines for each property type
            propertyTypes.forEach((propertyType, index) => {
                const typeData = dataByPropertyType[propertyType];
                if (typeData.length >= 3) { // Only create trend line if we have enough data
                    // Get selected trend period and type
                    const selectedPeriod = document.querySelector('input[name="trendPeriod"]:checked').value;
                    const selectedTimeFrame = document.querySelector('input[name="trendTimeFrame"]:checked').value;
                    const selectedTrendType = document.querySelector('input[name="trendType"]:checked').value;
                    
                    let trendData;
                    switch(selectedPeriod) {
                        case 'quarterly':
                            trendData = groupByQuarter(typeData);
                            break;
                        case 'yearly':
                            trendData = groupByYear(typeData);
                            break;
                        case 'monthly':
                        default:
                            trendData = groupByMonth(typeData);
                            break;
                    }
                    
                    // Calculate trend based on selected type
                    let linearTrendData;
                    switch(selectedTrendType) {
                        case 'polynomial':
                            linearTrendData = calculatePolynomialTrend(typeData, selectedTimeFrame);
                            break;
                        case 'cagr':
                            linearTrendData = calculateCAGRTrend(typeData, selectedTimeFrame);
                            break;
                        case 'moving':
                            linearTrendData = calculateMovingAverageTrend(typeData, null); // Always use all data
                            break;
                        case 'smoothed':
                            linearTrendData = calculateSmoothedTrend(typeData, null); // Always use all data
                            break;
                        case 'linear':
                        default:
                            linearTrendData = calculateLinearTrend(typeData, selectedTimeFrame);
                            break;
                    }
                    
                    const color = colors[index % colors.length];
                    
                    // Create interpolated trend data that matches the selected period data points
                    let interpolatedTrend;
                    if (selectedTrendType === 'moving' || selectedTrendType === 'smoothed') {
                        // For moving average and smoothed, use the trend data directly
                        interpolatedTrend = linearTrendData;
                    } else {
                        // For linear and polynomial, interpolate to match period data points
                        interpolatedTrend = interpolateTrendForPeriod(trendData, linearTrendData);
                    }
                    
                    const isHidden = propertyType === 'VACANT LAND' || propertyType === 'COMMERCIAL';
                    
                    // Overall trend line (render first as base)
                    datasets.push({
                        label: `${propertyType || 'Unknown'}`,
                        data: interpolatedTrend,
                        type: 'line',
                        backgroundColor: 'rgba(0, 0, 0, 0.1)',
                        borderColor: color.border,
                        borderWidth: 2,
                        fill: (selectedTrendType === 'moving' || selectedTrendType === 'smoothed') ? false : { above: "rgba(255, 0, 0, 0.2)", below: "rgba(0, 0, 255, 0.2)", target: "+1"},
                        tension: (selectedTrendType === 'moving' || selectedTrendType === 'smoothed') ? 0.4 : 0.1,
                        pointRadius: 0,
                        borderDash: [10, 5],
                        hidden: isHidden,
                        legendGroup: propertyType,
                        trendType: 'overall'
                    });
                
                    // Period trend line (on top)
                    datasets.push({
                        label: `${propertyType || 'Unknown'}`,
                        data: trendData,
                        type: 'line',
                        backgroundColor: color.bg,
                        borderColor: color.border,
                        borderWidth: 3,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 4,
                        hidden: isHidden,
                        legendGroup: propertyType,
                        trendType: selectedPeriod
                    });
                }
            });
            
            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Property Prices in ${locality.replace(/_/g, ' ')}`
                        },
                        legend: {
                            display: true,
                            onClick: function(e, legendItem, legend) {
                                const chart = legend.chart;
                                const datasetIndex = legendItem.datasetIndex;
                                const dataset = chart.data.datasets[datasetIndex];
                                
                                // Toggle visibility for all datasets with the same legendGroup
                                if (dataset.legendGroup) {
                                    chart.data.datasets.forEach((ds, index) => {
                                        if (ds.legendGroup === dataset.legendGroup) {
                                            const meta = chart.getDatasetMeta(index);
                                            meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
                                        }
                                    });
                                } else {
                                    // Default behavior for individual sales datasets
                                    const meta = chart.getDatasetMeta(datasetIndex);
                                    meta.hidden = meta.hidden === null ? !chart.data.datasets[datasetIndex].hidden : null;
                                }
                                
                                chart.update();
                            },
                            labels: {
                                filter: function(legendItem, chartData) {
                                    // Only show one legend item per property type for trend lines
                                    const dataset = chartData.datasets[legendItem.datasetIndex];
                                    if (dataset.legendGroup && dataset.trendType === 'overall') {
                                        return false; // Hide overall trend from legend
                                    }
                                    return true;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'month',
                                displayFormats: {
                                    month: 'MMM yyyy'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Price (AUD)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'nearest'
                    }
                }
            });
            
            // Calculate and display trend growth rate for RESIDENCE data
            const residenceData = dataByPropertyType['RESIDENCE'];
            if (residenceData && residenceData.length >= 3) {
                const selectedTrendType = document.querySelector('input[name="trendType"]:checked').value;
                const selectedTimeFrame = document.querySelector('input[name="trendTimeFrame"]:checked').value;
                
                let trendDataForGrowth;
                switch(selectedTrendType) {
                    case 'polynomial':
                        trendDataForGrowth = calculatePolynomialTrend(residenceData, selectedTimeFrame);
                        break;
                    case 'cagr':
                        trendDataForGrowth = calculateCAGRTrend(residenceData, selectedTimeFrame);
                        break;
                    case 'moving':
                        trendDataForGrowth = calculateMovingAverageTrend(residenceData, null);
                        break;
                    case 'smoothed':
                        trendDataForGrowth = calculateSmoothedTrend(residenceData, null);
                        break;
                    case 'linear':
                    default:
                        trendDataForGrowth = calculateLinearTrend(residenceData, selectedTimeFrame);
                        break;
                }
                
                const growthRate = calculateTrendGrowthRate(trendDataForGrowth, selectedTrendType, selectedTimeFrame);
                const growthDisplay = growthRate !== null ? 
                    (growthRate >= 0 ? '+' : '') + growthRate.toFixed(1) + '%' : 
                    'N/A';
                
                document.getElementById('trendGrowth').textContent = growthDisplay;
            } else {
                document.getElementById('trendGrowth').textContent = 'N/A';
            }
            
            document.getElementById('stats').style.display = 'grid';
        }

        function interpolateTrendForPeriod(periodData, linearTrendData) {
            if (linearTrendData.length < 2 || periodData.length === 0) return [];
            
            const [start, end] = linearTrendData;
            const slope = (end.y - start.y) / (end.x.getTime() - start.x.getTime());
            
            return periodData.map(point => ({
                x: point.x,
                y: start.y + slope * (point.x.getTime() - start.x.getTime())
            }));
        }


        function groupDataByPropertyType(data) {
            const grouped = {};
            const allowedTypes = ['RESIDENCE', 'VACANT LAND', 'COMMERCIAL'];
            
            data.forEach(item => {
                const propertyType = item.propertyType || 'Unknown';
                
                // Only include allowed property types
                if (allowedTypes.includes(propertyType)) {
                    if (!grouped[propertyType]) {
                        grouped[propertyType] = [];
                    }
                    grouped[propertyType].push(item);
                }
            });
            
            return grouped;
        }

        function calculateLinearTrend(data, timeFrameYears = null) {
            if (data.length < 2) return [];
            
            // Filter data based on time frame if specified
            let filteredData = data;
            if (timeFrameYears && timeFrameYears !== 'all') {
                const cutoffDate = new Date();
                cutoffDate.setFullYear(cutoffDate.getFullYear() - parseInt(timeFrameYears));
                filteredData = data.filter(item => item.date >= cutoffDate);
            }
            
            if (filteredData.length < 2) return [];
            
            // Convert dates to numeric values (time in milliseconds)
            const dataPoints = filteredData.map(item => ({
                x: item.date.getTime(),
                y: item.price
            }));
            
            // Calculate linear regression
            const n = dataPoints.length;
            const sumX = dataPoints.reduce((sum, point) => sum + point.x, 0);
            const sumY = dataPoints.reduce((sum, point) => sum + point.y, 0);
            const sumXY = dataPoints.reduce((sum, point) => sum + point.x * point.y, 0);
            const sumXX = dataPoints.reduce((sum, point) => sum + point.x * point.x, 0);
            
            // Calculate slope (m) and y-intercept (b) for y = mx + b
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Create trend line data points - extend across the full original data range
            const sortedOriginalData = [...data].sort((a, b) => a.date - b.date);
            const startDate = sortedOriginalData[0].date;
            const endDate = sortedOriginalData[sortedOriginalData.length - 1].date;
            
            // Extend the trend line slightly beyond the data range
            const timeRange = endDate.getTime() - startDate.getTime();
            const extendedStart = new Date(startDate.getTime() - timeRange * 0.05);
            const extendedEnd = new Date(endDate.getTime() + timeRange * 0.05);
            
            return [
                {
                    x: extendedStart,
                    y: Math.max(1000, slope * extendedStart.getTime() + intercept) // Minimum $1000 to prevent zero values
                },
                {
                    x: extendedEnd,
                    y: Math.max(1000, slope * extendedEnd.getTime() + intercept) // Minimum $1000 to prevent zero values
                }
            ];
        }

        function calculateCAGRTrend(data, timeFrameYears = null) {
            if (data.length < 2) return [];
            
            // Filter data based on time frame if specified
            let filteredData = data;
            if (timeFrameYears && timeFrameYears !== 'all') {
                const cutoffDate = new Date();
                cutoffDate.setFullYear(cutoffDate.getFullYear() - parseInt(timeFrameYears));
                filteredData = data.filter(item => item.date >= cutoffDate);
            }
            
            if (filteredData.length < 2) return [];
            
            // Sort data to get earliest and latest points
            const sortedData = [...filteredData].sort((a, b) => a.date - b.date);
            const startPoint = sortedData[0];
            const endPoint = sortedData[sortedData.length - 1];
            
            // Calculate CAGR and create a straight line
            const timeSpanMs = endPoint.date.getTime() - startPoint.date.getTime();
            const timeSpanYears = timeSpanMs / (1000 * 60 * 60 * 24 * 365.25);
            
            if (timeSpanYears <= 0) return [];
            
            const cagr = Math.pow(endPoint.price / startPoint.price, 1 / timeSpanYears);
            
            // Create trend line points from start to end based on CAGR
            return [
                {
                    x: startPoint.date,
                    y: startPoint.price
                },
                {
                    x: endPoint.date,
                    y: endPoint.price
                }
            ];
        }

        function calculatePolynomialTrend(data, timeFrameYears = null) {
            if (data.length < 5) return [];
            
            // Filter data based on time frame if specified
            let filteredData = data;
            if (timeFrameYears && timeFrameYears !== 'all') {
                const cutoffDate = new Date();
                cutoffDate.setFullYear(cutoffDate.getFullYear() - parseInt(timeFrameYears));
                filteredData = data.filter(item => item.date >= cutoffDate);
            }
            
            if (filteredData.length < 5) return [];
            
            // Use moving averages to create a smoother polynomial trend
            const sortedData = [...filteredData].sort((a, b) => a.date - b.date);
            const windowSize = Math.max(3, Math.floor(sortedData.length / 10));
            const smoothedPoints = [];
            
            // Create smoothed points using simple moving average
            for (let i = windowSize; i < sortedData.length - windowSize; i += windowSize) {
                const window = sortedData.slice(i - windowSize, i + windowSize);
                const avgPrice = window.reduce((sum, item) => sum + item.price, 0) / window.length;
                smoothedPoints.push({
                    x: sortedData[i].date,
                    y: avgPrice
                });
            }
            
            if (smoothedPoints.length < 3) {
                // Fall back to linear if not enough points
                return calculateLinearTrend(data, timeFrameYears);
            }
            
            return smoothedPoints;
        }

        function calculateSmoothedTrend(data, timeFrameYears = null) {
            if (data.length < 6) return [];
            
            // Filter data based on time frame if specified
            let filteredData = data;
            if (timeFrameYears && timeFrameYears !== 'all') {
                const cutoffDate = new Date();
                cutoffDate.setFullYear(cutoffDate.getFullYear() - parseInt(timeFrameYears));
                filteredData = data.filter(item => item.date >= cutoffDate);
            }
            
            if (filteredData.length < 6) return [];
            
            // Simple exponential smoothing - much faster than LOWESS
            const sortedData = [...filteredData].sort((a, b) => a.date - b.date);
            const alpha = 0.3; // Smoothing factor
            const smoothed = [];
            
            // Initialize with first value
            let smoothedValue = sortedData[0].price;
            smoothed.push({
                x: sortedData[0].date,
                y: smoothedValue
            });
            
            // Apply exponential smoothing
            for (let i = 1; i < sortedData.length; i++) {
                smoothedValue = alpha * sortedData[i].price + (1 - alpha) * smoothedValue;
                smoothed.push({
                    x: sortedData[i].date,
                    y: smoothedValue
                });
            }
            
            return smoothed;
        }

        function calculateMovingAverageTrend(data, timeFrameYears = null) {
            if (data.length < 12) return [];
            
            // Filter data based on time frame if specified
            let filteredData = data;
            if (timeFrameYears && timeFrameYears !== 'all') {
                const cutoffDate = new Date();
                cutoffDate.setFullYear(cutoffDate.getFullYear() - parseInt(timeFrameYears));
                filteredData = data.filter(item => item.date >= cutoffDate);
            }
            
            if (filteredData.length < 12) return [];
            
            // Sort by date and calculate rolling average
            const sortedData = [...filteredData].sort((a, b) => a.date - b.date);
            const windowSize = Math.min(12, Math.floor(sortedData.length / 8));
            const movingAvg = [];
            
            for (let i = windowSize - 1; i < sortedData.length; i++) {
                const window = sortedData.slice(i - windowSize + 1, i + 1);
                const avgPrice = window.reduce((sum, item) => sum + item.price, 0) / window.length;
                
                movingAvg.push({
                    x: sortedData[i].date,
                    y: avgPrice
                });
            }
            
            return movingAvg;
        }

        function groupByQuarter(data) {
            const quarterlyGroups = {};
            
            data.forEach(item => {
                const year = item.date.getFullYear();
                const quarter = Math.floor(item.date.getMonth() / 3) + 1;
                const quarterKey = `${year}-Q${quarter}`;
                
                if (!quarterlyGroups[quarterKey]) {
                    quarterlyGroups[quarterKey] = [];
                }
                quarterlyGroups[quarterKey].push(item.price);
            });
            
            return Object.keys(quarterlyGroups).map(quarterKey => {
                const [year, quarter] = quarterKey.split('-');
                const quarterNum = parseInt(quarter.substring(1));
                const prices = quarterlyGroups[quarterKey].sort((a, b) => a - b);
                const medianPrice = prices[Math.floor(prices.length / 2)];
                
                // Use middle month of quarter for x-axis positioning
                const middleMonth = (quarterNum - 1) * 3 + 1; // Q1=Jan(1), Q2=Apr(4), Q3=Jul(7), Q4=Oct(10)
                
                return {
                    x: new Date(parseInt(year), middleMonth, 15),
                    y: medianPrice
                };
            }).sort((a, b) => a.x - b.x);
        }

        function groupByYear(data) {
            const yearlyGroups = {};
            
            data.forEach(item => {
                const year = item.date.getFullYear();
                
                if (!yearlyGroups[year]) {
                    yearlyGroups[year] = [];
                }
                yearlyGroups[year].push(item.price);
            });
            
            return Object.keys(yearlyGroups).map(year => {
                const prices = yearlyGroups[year].sort((a, b) => a - b);
                const medianPrice = prices[Math.floor(prices.length / 2)];
                
                return {
                    x: new Date(parseInt(year), 6, 1), // Use July 1st as mid-year point
                    y: medianPrice
                };
            }).sort((a, b) => a.x - b.x);
        }

        function groupByMonth(data) {
            const monthlyGroups = {};
            
            data.forEach(item => {
                const monthKey = `${item.date.getFullYear()}-${item.date.getMonth()}`;
                if (!monthlyGroups[monthKey]) {
                    monthlyGroups[monthKey] = [];
                }
                monthlyGroups[monthKey].push(item.price);
            });
            
            return Object.keys(monthlyGroups).map(monthKey => {
                const [year, month] = monthKey.split('-').map(Number);
                const prices = monthlyGroups[monthKey].sort((a, b) => a - b);
                const medianPrice = prices[Math.floor(prices.length / 2)];
                
                return {
                    x: new Date(year, month, 15), // Use 15th of month
                    y: medianPrice
                };
            }).sort((a, b) => a.x - b.x);
        }

        function calculateTransactionVolume(data) {
            if (!data || data.length === 0) return [];
            
            const monthlyGroups = {};
            
            data.forEach(item => {
                const year = item.date.getFullYear();
                const month = item.date.getMonth(); // 0-based
                const key = `${year}-${String(month + 1).padStart(2, '0')}`;
                
                if (!monthlyGroups[key]) {
                    monthlyGroups[key] = 0;
                }
                monthlyGroups[key]++;
            });
            
            return Object.keys(monthlyGroups).map(key => {
                const [year, month] = key.split('-').map(Number);
                return {
                    x: new Date(year, month - 1, 15), // Use mid-month
                    y: monthlyGroups[key]
                };
            }).sort((a, b) => a.x - b.x);
        }

        function calculateTrendGrowthRate(trendData, selectedTrendType, selectedTimeFrame) {
            if (!trendData || trendData.length < 2) {
                console.log('Trend growth: insufficient data points', trendData?.length);
                return null;
            }
            
            let startValue, endValue, timeSpanYears;
            
            if (selectedTrendType === 'linear') {
                // For linear regression, calculate growth from trend line values at data endpoints
                const residenceData = window.currentLocalityData ? 
                    window.currentLocalityData.filter(item => item.propertyType === 'RESIDENCE') : [];
                
                if (residenceData.length < 2) {
                    console.log('Linear trend growth: insufficient residence data, found', residenceData.length, 'records');
                    console.log('Available property types:', window.currentLocalityData ? 
                        [...new Set(window.currentLocalityData.map(item => item.propertyType))] : 'No data');
                    return null;
                }
                
                let filteredData = residenceData;
                
                // Apply the same time filtering that was used to generate the trend
                if (selectedTimeFrame && selectedTimeFrame !== 'all') {
                    const years = parseInt(selectedTimeFrame);
                    const cutoffDate = new Date();
                    cutoffDate.setFullYear(cutoffDate.getFullYear() - years);
                    filteredData = residenceData.filter(item => item.date >= cutoffDate);
                }
                
                if (filteredData.length < 2) {
                    console.log('Linear trend growth: insufficient filtered data');
                    return null;
                }
                
                // Calculate the linear regression coefficients for the filtered data
                const dataPoints = filteredData.map(item => ({
                    x: item.date.getTime(),
                    y: item.price
                }));
                
                const n = dataPoints.length;
                const sumX = dataPoints.reduce((sum, point) => sum + point.x, 0);
                const sumY = dataPoints.reduce((sum, point) => sum + point.y, 0);
                const sumXY = dataPoints.reduce((sum, point) => sum + point.x * point.y, 0);
                const sumXX = dataPoints.reduce((sum, point) => sum + point.x * point.x, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                // Get the actual date range of the filtered data
                const sortedData = [...filteredData].sort((a, b) => a.date - b.date);
                const startDate = sortedData[0].date;
                const endDate = sortedData[sortedData.length - 1].date;
                
                // Calculate trend line values at these endpoints
                startValue = Math.max(1000, slope * startDate.getTime() + intercept);
                endValue = Math.max(1000, slope * endDate.getTime() + intercept);
                
                const timeSpanMs = endDate.getTime() - startDate.getTime();
                timeSpanYears = timeSpanMs / (1000 * 60 * 60 * 24 * 365.25);
                
                console.log('Linear trend growth calculation:', {
                    selectedTimeFrame,
                    dataPoints: n,
                    startDate,
                    endDate,
                    startValue,
                    endValue,
                    timeSpanYears,
                    slope,
                    expectedGrowth: ((endValue / startValue) ** (1 / timeSpanYears) - 1) * 100
                });
            } else if (selectedTrendType === 'cagr') {
                // For CAGR, use the trend data directly (start and end points)
                const sortedTrend = [...trendData].sort((a, b) => a.x.getTime() - b.x.getTime());
                startValue = sortedTrend[0].y;
                endValue = sortedTrend[sortedTrend.length - 1].y;
                
                const timeSpanMs = sortedTrend[sortedTrend.length - 1].x.getTime() - sortedTrend[0].x.getTime();
                timeSpanYears = timeSpanMs / (1000 * 60 * 60 * 24 * 365.25);
                
                console.log('CAGR trend growth calculation:', {
                    selectedTimeFrame,
                    startValue,
                    endValue,
                    timeSpanYears,
                    expectedGrowth: ((endValue / startValue) ** (1 / timeSpanYears) - 1) * 100
                });
            } else {
                // For other trend types, use actual data endpoints
                const sortedTrend = [...trendData].sort((a, b) => a.x.getTime() - b.x.getTime());
                
                // For time-based trends, use the specified timeframe
                if (selectedTimeFrame && selectedTimeFrame !== 'all') {
                    const years = parseInt(selectedTimeFrame);
                    const cutoffDate = new Date();
                    cutoffDate.setFullYear(cutoffDate.getFullYear() - years);
                    
                    const recentTrend = sortedTrend.filter(point => point.x >= cutoffDate);
                    if (recentTrend.length >= 2) {
                        startValue = recentTrend[0].y;
                        endValue = recentTrend[recentTrend.length - 1].y;
                        timeSpanYears = years;
                    } else {
                        return null;
                    }
                } else {
                    startValue = sortedTrend[0].y;
                    endValue = sortedTrend[sortedTrend.length - 1].y;
                    
                    const timeSpanMs = sortedTrend[sortedTrend.length - 1].x.getTime() - sortedTrend[0].x.getTime();
                    timeSpanYears = timeSpanMs / (1000 * 60 * 60 * 24 * 365.25);
                }
            }
            
            // Ensure we have valid values - be more lenient with validation
            if (timeSpanYears <= 0) {
                console.log('Trend growth validation failed: invalid time span', timeSpanYears);
                return null;
            }
            
            // Handle zero start value by using a small positive value
            if (startValue <= 0) {
                console.log('Adjusting zero start value to prevent division issues');
                startValue = Math.min(1000, endValue * 0.01); // Use 1% of end value or $1000, whichever is smaller
            }
            
            // Calculate compound annual growth rate (CAGR)
            const cagr = Math.pow(endValue / startValue, 1 / timeSpanYears) - 1;
            
            console.log('CAGR calculation:', {
                cagr,
                percentage: cagr * 100,
                isValid: !isNaN(cagr) && isFinite(cagr)
            });
            
            // Sanity check for reasonable values - be more lenient
            if (isNaN(cagr) || !isFinite(cagr)) {
                return null;
            }
            
            return cagr * 100; // Convert to percentage
        }

        function displayVolumeChart(data, locality) {
            const ctx = document.getElementById('volumeChart').getContext('2d');
            
            if (volumeChart) {
                volumeChart.destroy();
            }
            
            // Calculate transaction volume by month
            const volumeData = calculateTransactionVolume(data);
            
            // Create volume chart
            volumeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    datasets: [{
                        label: 'Monthly Transaction Volume',
                        data: volumeData,
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'year',
                                displayFormats: {
                                    year: 'yyyy'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Transactions'
                            },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Transaction Volume in ${locality.toUpperCase()} (Monthly)`
                        },
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        function updateStats(data, outliersRemoved = 0) {
            const totalSales = data.length;
            
            // Get latest 100 records for average and median
            const sortedData = [...data].sort((a, b) => b.date - a.date);
            const latestRecords = sortedData.slice(0, Math.min(100, data.length));
            
            let avgPrice, medianPrice;
            if (latestRecords.length > 0) {
                const latestPrices = latestRecords.map(item => item.price);
                avgPrice = latestPrices.reduce((sum, price) => sum + price, 0) / latestPrices.length;
                const sortedLatestPrices = [...latestPrices].sort((a, b) => a - b);
                medianPrice = sortedLatestPrices[Math.floor(sortedLatestPrices.length / 2)];
            } else {
                // Fallback to all data if somehow no records
                const allPrices = data.map(item => item.price);
                avgPrice = allPrices.reduce((sum, price) => sum + price, 0) / allPrices.length;
                const sortedAllPrices = [...allPrices].sort((a, b) => a - b);
                medianPrice = sortedAllPrices[Math.floor(sortedAllPrices.length / 2)];
            }
            
            const allPrices = data.map(item => item.price);
            const minPrice = Math.min(...allPrices);
            const maxPrice = Math.max(...allPrices);
            
            // Count property types
            const propertyTypes = {};
            data.forEach(item => {
                if (item.propertyType) {
                    propertyTypes[item.propertyType] = (propertyTypes[item.propertyType] || 0) + 1;
                }
            });
            
            const topPropertyTypes = Object.entries(propertyTypes)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .map(([type, count]) => `<div class="stat-value property-types"><strong>${type}</strong><br><small>(${count} sales)</small></div>`)
                .join('');
            
            document.getElementById('totalSales').textContent = totalSales.toLocaleString();
            document.getElementById('avgPrice').textContent = '$' + Math.round(avgPrice).toLocaleString();
            document.getElementById('medianPrice').textContent = '$' + medianPrice.toLocaleString();
            document.getElementById('priceRange').textContent = 
                '$' + minPrice.toLocaleString() + ' - $' + maxPrice.toLocaleString();
            document.getElementById('outliersRemoved').textContent = outliersRemoved.toLocaleString();
            document.getElementById('propertyTypes').innerHTML = topPropertyTypes || '<div class="stat-value property-types">Unknown</div>';
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        function hideChart() {
            if (chart) {
                chart.destroy();
                chart = null;
            }
            if (volumeChart) {
                volumeChart.destroy();
                volumeChart = null;
            }
            document.getElementById('stats').style.display = 'none';
        }
    </script>
</body>
</html>